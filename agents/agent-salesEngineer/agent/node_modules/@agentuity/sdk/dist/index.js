var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/server/otel.ts
import { context, propagation } from "@opentelemetry/api";
function injectTraceContextToHeaders(headers = {}) {
  let _headers = headers;
  if (headers instanceof Headers) {
    _headers = headers.toJSON();
  }
  const carrier = { ..._headers };
  const currentContext = context.active();
  propagation.inject(currentContext, carrier);
  return carrier;
}
function injectTraceContextToNodeResponse(res) {
  const carrier = {};
  const currentContext = context.active();
  propagation.inject(currentContext, carrier);
  for (const [key, value] of Object.entries(carrier)) {
    res.setHeader(key, value);
  }
}
function extractTraceContextFromNodeRequest(req) {
  const carrier = {};
  for (const [key, value] of Object.entries(req.headers)) {
    if (typeof value === "string") {
      carrier[key.toLowerCase()] = value;
    } else if (Array.isArray(value)) {
      carrier[key.toLowerCase()] = value[0] || "";
    }
  }
  const activeContext = context.active();
  return propagation.extract(activeContext, carrier);
}
function extractTraceContextFromBunRequest(req) {
  const carrier = {};
  req.headers.forEach((value, key) => {
    carrier[key.toLowerCase()] = value;
  });
  const activeContext = context.active();
  return propagation.extract(activeContext, carrier);
}
var init_otel = __esm({
  "src/server/otel.ts"() {
    "use strict";
  }
});

// src/server/util.ts
import { SpanStatusCode } from "@opentelemetry/api";
import { ReadableStream } from "node:stream/web";
function safeStringify(obj) {
  const seen = /* @__PURE__ */ new WeakSet();
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (seen.has(value)) {
        return "[Circular]";
      }
      seen.add(value);
    }
    return value;
  });
}
function safeParse(text, defaultValue) {
  try {
    if (!text || text.trim() === "") {
      return defaultValue;
    }
    return JSON.parse(text);
  } catch (error) {
    return defaultValue;
  }
}
function getRoutesHelpText(host, routes) {
  const buffer = ["The following Agent routes are available:", ""];
  for (const route of routes) {
    buffer.push(`${route.method} ${route.path} [${route.agent.name}]`);
  }
  buffer.push("");
  if (process.platform === "darwin" || process.platform === "linux") {
    buffer.push("Example usage:");
    buffer.push("");
    buffer.push(
      `curl http://${host}${routes[0].path} \\
	--json '{"prompt":"Hello"}'`
    );
    buffer.push("");
  }
  return buffer.join("\n");
}
async function toWelcomePrompt({
  data,
  contentType
}) {
  if (data instanceof Buffer) {
    return {
      data: data.toString("base64"),
      contentType
    };
  }
  if (data instanceof Uint8Array) {
    return {
      data: Buffer.from(data).toString("base64"),
      contentType
    };
  }
  if (data instanceof ArrayBuffer) {
    return {
      data: Buffer.from(data).toString("base64"),
      contentType
    };
  }
  if (data instanceof Blob) {
    return {
      data: Buffer.from(await data.arrayBuffer()).toString("base64"),
      contentType
    };
  }
  if (data instanceof ReadableStream) {
    const reader = data.getReader();
    let buffer = Buffer.alloc(0);
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer = Buffer.concat([buffer, value]);
    }
    return {
      data: buffer.toString("base64"),
      contentType
    };
  }
  if (typeof data === "string") {
    if ((contentType.includes("text/") || contentType.includes("json")) && !isBase64.test(data)) {
      return {
        data: Buffer.from(data).toString("base64"),
        contentType
      };
    }
    return {
      data,
      contentType
    };
  }
  if (typeof data === "object") {
    return {
      data: Buffer.from(safeStringify(data)).toString("base64"),
      contentType
    };
  }
  throw new Error("Invalid data type (toWelcomePrompt");
}
async function dataTypeToBuffer(args) {
  if (args instanceof DataHandler) {
    const payload = args;
    return payload.buffer();
  }
  if (args === null || args === void 0) {
    return Buffer.alloc(0);
  }
  if (typeof args === "string") {
    return Buffer.from(args, "utf-8");
  }
  if (typeof args === "object") {
    if (args instanceof DataHandler) {
      return args.buffer();
    }
    if (args instanceof ArrayBuffer) {
      return Buffer.from(args);
    }
    if (args instanceof Buffer) {
      return args;
    }
    if (args instanceof Blob) {
      const blob = await args.arrayBuffer();
      return Buffer.from(blob);
    }
    if (args instanceof Uint8Array) {
      return Buffer.from(args);
    }
    if (args instanceof ReadableStream) {
      const reader = args.getReader();
      let buffer = Buffer.alloc(0);
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer = Buffer.concat([buffer, value]);
      }
      return buffer;
    }
    return Buffer.from(safeStringify(args));
  }
  throw new Error("Invalid data type (toDataType)");
}
async function fromDataType(data, contentType, metadata) {
  if (data instanceof DataHandler) {
    return {
      data,
      metadata
    };
  }
  const response = {
    data: null,
    // Will be set in each case
    metadata
    // Always include metadata
  };
  if (data === null || data === void 0) {
    response.data = new DataHandler("", "text/plain");
    return response;
  }
  if (typeof data === "string") {
    response.data = new DataHandler(data, contentType ?? "text/plain");
    return response;
  }
  if (typeof data === "object") {
    if (data instanceof DataHandler) {
      response.data = data;
      return response;
    }
    if (data instanceof ArrayBuffer) {
      response.data = new DataHandler(
        Buffer.from(data),
        contentType ?? "application/octet-stream"
      );
      return response;
    }
    if (data instanceof Buffer) {
      response.data = new DataHandler(
        data,
        contentType ?? "application/octet-stream"
      );
      return response;
    }
    if (data instanceof Blob) {
      const buffer = await data.arrayBuffer();
      response.data = new DataHandler(
        Buffer.from(buffer),
        contentType ?? "application/octet-stream"
      );
      return response;
    }
    if (data instanceof Uint8Array) {
      response.data = new DataHandler(
        Buffer.from(data),
        contentType ?? "application/octet-stream"
      );
      return response;
    }
    if (data instanceof ReadableStream) {
      response.data = new DataHandler(
        data,
        contentType ?? "application/octet-stream"
      );
      return response;
    }
    response.data = new DataHandler(
      safeStringify(data),
      contentType ?? "application/json"
    );
    return response;
  }
  throw new Error("Invalid data type (fromDataType)");
}
async function createStreamingResponse(origin, server, span, routeResult) {
  const responseheaders = injectTraceContextToHeaders({
    Server: server
  });
  let resp;
  try {
    resp = await routeResult;
  } catch (error) {
    const { stack, message } = error;
    let errorMessage = message;
    if (devmode) {
      errorMessage = stack ?? errorMessage;
    }
    responseheaders["Content-Type"] = "text/plain";
    return new Response(errorMessage, {
      status: 500,
      headers: responseheaders
    });
  }
  if (resp.metadata) {
    for (const key in resp.metadata) {
      let value = resp.metadata[key];
      if (typeof value === "string") {
        value = safeParseIfLooksLikeJson(value) ?? value;
      } else {
        value = JSON.stringify(value);
      }
      responseheaders[`x-agentuity-${key}`] = value;
    }
  }
  if (resp.data?.contentType) {
    responseheaders["Content-Type"] = resp.data.contentType;
  }
  if (origin) {
    responseheaders["Access-Control-Allow-Origin"] = origin;
    responseheaders["Access-Control-Allow-Methods"] = "GET, PUT, DELETE, PATCH, OPTIONS, POST";
    responseheaders["Access-Control-Allow-Headers"] = "Content-Type, Authorization";
  }
  if (resp instanceof Response) {
    for (const [key, value] of Object.entries(responseheaders)) {
      resp.headers.set(key, value);
    }
    return resp;
  }
  const stream = await resp.data.stream();
  span.setStatus({ code: SpanStatusCode.OK });
  return new Response(stream, {
    status: 200,
    headers: responseheaders
  });
}
function getRequestFromHeaders(headers, runId) {
  const metadata = metadataFromHeaders(headers);
  let trigger = metadata.trigger;
  let scope = "local";
  if ("scope" in metadata) {
    scope = metadata.scope;
    delete metadata.scope;
  }
  if ("trigger" in metadata) {
    trigger = metadata.trigger;
    delete metadata.trigger;
  }
  delete metadata.trigger;
  return {
    contentType: headers["content-type"] ?? "application/octet-stream",
    metadata,
    runId,
    trigger: trigger ?? "manual",
    scope
  };
}
function safeParseIfLooksLikeJson(value) {
  if (typeof value !== "string") {
    return value;
  }
  const trimmed = value.trim();
  if (trimmed.startsWith("{") && trimmed.endsWith("}") || trimmed.startsWith("[") && trimmed.endsWith("]")) {
    return safeParse(trimmed, value);
  }
  return value;
}
function metadataFromHeaders(headers) {
  const metadata = {};
  for (const [key, value] of Object.entries(headers)) {
    if (key.startsWith("x-agentuity-")) {
      switch (key) {
        case "x-agentuity-metadata": {
          const md = safeParse(value);
          if (md && typeof md === "object" && !Array.isArray(md)) {
            for (const [k, v] of Object.entries(md)) {
              metadata[k] = safeParseIfLooksLikeJson(v);
            }
          }
          continue;
        }
        case "x-agentuity-headers": {
          const md = safeParse(value);
          const kv2 = {};
          if ("content-type" in headers) {
            kv2["content-type"] = headers["content-type"];
          }
          if (md && typeof md === "object" && !Array.isArray(md)) {
            for (const [k, v] of Object.entries(md)) {
              if (k.startsWith("x-agentuity-")) {
                metadata[k.substring(12)] = safeParseIfLooksLikeJson(
                  v
                );
              } else {
                kv2[k] = safeParseIfLooksLikeJson(v);
              }
            }
          }
          metadata.headers = kv2;
          break;
        }
        default: {
          const mdkey = key.substring(12);
          metadata[mdkey] = safeParseIfLooksLikeJson(value);
          break;
        }
      }
    }
  }
  return metadata;
}
function setMetadataInHeaders(headers, metadata) {
  for (const [key, value] of Object.entries(metadata)) {
    if (value === null || value === void 0) {
      continue;
    }
    switch (typeof value) {
      case "string":
        headers[`x-agentuity-${key}`] = value;
        break;
      case "number":
        headers[`x-agentuity-${key}`] = value.toString();
        break;
      case "boolean":
        headers[`x-agentuity-${key}`] = value.toString();
        break;
      default:
        headers[`x-agentuity-${key}`] = safeStringify(value);
        break;
    }
  }
}
function headersToRecord(headers) {
  if (typeof headers.toJSON === "function") {
    return headers.toJSON();
  }
  const record = {};
  headers.forEach((value, key) => {
    record[key] = value;
  });
  return record;
}
function shouldIgnoreStaticFile(pathname) {
  return pathname === "/favicon.ico" || pathname === "/robots.txt" || pathname === "/humans.txt" || pathname === "/security.txt" || pathname === "/sitemap.xml" || pathname === "/favicon.png" || pathname === "/apple-touch-icon.png" || pathname === "/apple-touch-icon-precomposed.png" || pathname === "/crossdomain.xml" || pathname === "/browserconfig.xml" || pathname === "/manifest.json";
}
var isBase64, devmode;
var init_util = __esm({
  "src/server/util.ts"() {
    "use strict";
    init_data();
    init_otel();
    isBase64 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    devmode = process.env.AGENTUITY_SDK_DEV_MODE === "true";
  }
});

// src/types.ts
function isDataObject(value) {
  if (value && typeof value === "object" && "contentType" in value) {
    return true;
  }
  return false;
}
function isReadableStream(value) {
  if (typeof value === "object" && value !== null) {
    return "getReader" in value;
  }
  return false;
}
function isDataType(value) {
  if (value === null || value === void 0) {
    return false;
  }
  if (typeof value === "string") {
    return true;
  }
  if (isDataObject(value)) {
    return true;
  }
  if (typeof value === "object") {
    if (value instanceof Buffer || value instanceof Uint8Array || value instanceof ArrayBuffer || value instanceof Blob) {
      return true;
    }
    if (isReadableStream(value)) {
      return true;
    }
  }
  return isJsonObject(value);
}
function isJsonObject(value) {
  if (value === null || value === void 0) {
    return true;
  }
  if (Array.isArray(value)) {
    return value.every(isJsonObject);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    return true;
  }
  if (typeof value === "object") {
    return Object.keys(value).every(
      (key) => isJsonObject(value[key])
    );
  }
  return false;
}
var init_types = __esm({
  "src/types.ts"() {
    "use strict";
  }
});

// src/router/response.ts
var AgentResponseHandler;
var init_response = __esm({
  "src/router/response.ts"() {
    "use strict";
    init_types();
    init_data();
    init_util();
    AgentResponseHandler = class {
      /**
       * redirect the current request another agent within the same project
       */
      async handoff(agent, args) {
        if (isJsonObject(args?.metadata)) {
          const result = {
            redirect: true,
            agent,
            invocation: args
          };
          return result;
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return an empty response with optional metadata
       */
      async empty(metadata) {
        if (isJsonObject(metadata)) {
          return {
            data: new DataHandler("", "text/plain"),
            metadata
          };
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a JSON response with optional metadata
       */
      async json(data, metadata) {
        if (!isJsonObject(data)) {
          throw new Error("data must be a JsonObject");
        }
        if (isJsonObject(metadata)) {
          return {
            data: new DataHandler(safeStringify(data), "application/json"),
            metadata
          };
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a text response with optional metadata
       */
      async text(data, metadata) {
        if (isJsonObject(metadata)) {
          return {
            data: new DataHandler(data, "text/plain"),
            metadata
          };
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a binary response with optional metadata
       */
      binary(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "application/octet-stream", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a PDF response with optional metadata
       */
      pdf(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "application/pdf", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a PNG response with optional metadata
       */
      png(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "image/png", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a JPEG response with optional metadata
       */
      jpeg(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "image/jpeg", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a GIF response with optional metadata
       */
      gif(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "image/gif", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a WebP response with optional metadata
       */
      webp(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "image/webp", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a MP3 response with optional metadata
       */
      mp3(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "audio/mpeg", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a MP4 response with optional metadata
       */
      mp4(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "audio/mp4", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a M4A response with optional metadata
       */
      m4a(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "audio/m4a", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a M4P response with optional metadata
       */
      m4p(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "audio/m4p", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a WebM response with optional metadata
       */
      webm(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "audio/webm", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a HTML response with optional metadata
       */
      async html(data, metadata) {
        if (isJsonObject(metadata)) {
          return {
            data: new DataHandler(data, "text/html"),
            metadata
          };
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a WAV response with optional metadata
       */
      wav(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "audio/wav", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return an OGG response with optional metadata
       */
      ogg(data, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, "audio/ogg", metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * stream a response to the client
       */
      async stream(stream, contentType, metadata) {
        if (isJsonObject(metadata)) {
          return {
            data: new DataHandler(
              stream,
              contentType ?? "application/octet-stream"
            ),
            metadata
          };
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a response with specific data and content type with optional metadata
       */
      data(data, contentType, metadata) {
        if (isJsonObject(metadata)) {
          return fromDataType(data, contentType, metadata);
        }
        throw new Error("metadata must be a JsonObject");
      }
      /**
       * return a markdown response with optional metadata
       */
      async markdown(content, metadata) {
        if (isJsonObject(metadata)) {
          return {
            data: new DataHandler(content, "text/markdown"),
            metadata
          };
        }
        throw new Error("metadata must be a JsonObject");
      }
    };
  }
});

// src/server/agents.ts
import { context as context2, trace, SpanStatusCode as SpanStatusCode2 } from "@opentelemetry/api";
var LocalAgentInvoker, RemoteAgentInvoker, AgentResolver;
var init_agents = __esm({
  "src/server/agents.ts"() {
    "use strict";
    init_types();
    init_api();
    init_util();
    init_otel();
    init_data();
    init_router();
    LocalAgentInvoker = class {
      port;
      id;
      name;
      description;
      projectId;
      /**
       * Creates a new local agent invoker
       *
       * @param port - The port the agent is running on
       * @param id - The agent ID
       * @param name - The agent name
       * @param projectId - The project ID
       * @param description - Optional description of the agent
       */
      constructor(port, id, name, projectId, description) {
        this.port = port;
        this.id = id;
        this.name = name;
        this.projectId = projectId;
        this.description = description;
      }
      async run(args) {
        if (!isJsonObject(args?.metadata)) {
          throw new Error("args.metadata must be a JsonObject");
        }
        const tracer = getTracer();
        const currentContext = context2.active();
        const span = tracer.startSpan(
          "remoteagent.run",
          {
            attributes: {
              "remote.agentId": this.id,
              "remote.agentName": this.name,
              "@agentuity/scope": "local"
            }
          },
          currentContext
        );
        const spanContext = trace.setSpan(currentContext, span);
        return await context2.with(spanContext, async () => {
          try {
            const body = args?.data ? await dataTypeToBuffer(args.data) : void 0;
            const headers = {
              "Content-Type": args?.contentType ?? "application/octet-stream",
              "x-agentuity-trigger": "agent"
            };
            if (args?.metadata) {
              setMetadataInHeaders(headers, args.metadata);
            }
            injectTraceContextToHeaders(headers);
            const resp = await fetch(`http://127.0.0.1:${this.port}/${this.id}`, {
              method: "POST",
              body,
              headers
            });
            if (resp.ok) {
              span.setAttribute("http.status_code", resp.status.toString());
              if (resp.body) {
                span.setStatus({ code: SpanStatusCode2.OK });
                return {
                  data: new DataHandler(
                    resp.body,
                    resp.headers.get("content-type") ?? "application/octet-stream"
                  ),
                  contentType: resp.headers.get("content-type") ?? "application/octet-stream",
                  metadata: metadataFromHeaders(headersToRecord(resp.headers))
                };
              }
            }
            throw new Error(await resp.text());
          } catch (ex) {
            recordException(span, ex, true);
            throw ex;
          } finally {
            span.end();
          }
        });
      }
    };
    RemoteAgentInvoker = class {
      logger;
      id;
      name;
      projectId;
      orgId;
      url;
      authorization;
      transactionId;
      /**
       * Creates a new remote agent invoker
       *
       * @param logger - The logger to use
       * @param url - The agent url endpoint to use
       * @param authorization - The agent authorization token
       * @param id - The agent id
       * @param name - The agent name
       * @param projectId - The project id
       * @param orgId - The organization id
       * @param transactionId - The transaction id
       */
      constructor(logger, url, authorization, id, name, projectId, orgId, transactionId) {
        this.logger = logger;
        this.url = url;
        this.authorization = authorization;
        this.id = id;
        this.name = name;
        this.projectId = projectId;
        this.orgId = orgId;
        this.transactionId = transactionId;
      }
      async run(args) {
        if (!isJsonObject(args?.metadata)) {
          throw new Error("args.metadata must be a JsonObject");
        }
        const tracer = getTracer();
        const currentContext = context2.active();
        const span = tracer.startSpan(
          "remoteagent.run",
          {
            attributes: {
              "@agentuity/agentId": this.id,
              "@agentuity/agentName": this.name,
              "@agentuity/orgId": this.orgId,
              "@agentuity/projectId": this.projectId,
              "@agentuity/transactionId": this.transactionId,
              "@agentuity/scope": "remote"
            }
          },
          currentContext
        );
        const spanContext = trace.setSpan(currentContext, span);
        return await context2.with(spanContext, async () => {
          try {
            const sdkVersion = getSDKVersion();
            const headers = {
              Authorization: `Bearer ${this.authorization}`,
              "Content-Type": args?.contentType ?? "application/octet-stream",
              "User-Agent": `Agentuity JS SDK/${sdkVersion}`,
              "x-agentuity-scope": "remote",
              "x-agentuity-trigger": "agent"
            };
            if (args?.metadata) {
              setMetadataInHeaders(headers, args.metadata);
            }
            injectTraceContextToHeaders(headers);
            const body = args?.data ? await dataTypeToBuffer(args.data) : void 0;
            this.logger.info("invoking remote agent");
            const resp = await fetch(this.url, {
              headers,
              body,
              method: "POST"
            });
            this.logger.info("invoked remote agent, returned: %d", resp.status);
            span.setAttribute("http.status_code", resp.status);
            if (resp.ok) {
              span.setStatus({ code: SpanStatusCode2.OK });
            } else {
              span.setStatus({
                code: SpanStatusCode2.ERROR,
                message: await resp.text()
              });
              throw new Error(await resp.text());
            }
            const metadata = metadataFromHeaders(headersToRecord(resp.headers));
            const contentType = resp.headers.get("content-type") ?? "application/octet-stream";
            this.logger.debug(
              "invoked remote agent, returned metadata: %s, content-type: %s",
              metadata,
              contentType
            );
            return {
              data: new DataHandler(
                resp.body,
                contentType
              ),
              metadata
            };
          } catch (ex) {
            recordException(span, ex);
            throw ex;
          } finally {
            span.end();
          }
        });
      }
    };
    AgentResolver = class {
      logger;
      agents;
      port;
      projectId;
      currentAgentId;
      /**
       * Creates a new agent resolver
       *
       * @param logger - The logger to use
       * @param agents - List of available server agents
       * @param port - The port the server is running on
       * @param projectId - The project ID
       * @param currentAgentId - The ID of the current agent
       */
      constructor(logger, agents, port, projectId, currentAgentId) {
        this.logger = logger;
        this.agents = agents;
        this.port = port;
        this.projectId = projectId;
        this.currentAgentId = currentAgentId;
      }
      /**
       * Gets an agent implementation based on the provided parameters
       *
       * @param params - Parameters to identify the agent
       * @returns A promise that resolves to the agent implementation
       * @throws Error if the agent is not found or if there's an agent loop
       */
      async getAgent(params) {
        const agent = this.agents.find((a) => {
          if ("id" in params && a.id === params.id) {
            return a;
          }
          if ("name" in params && a.name === params.name && (this.projectId === params.projectId || !params.projectId)) {
            return a;
          }
          return null;
        });
        if (agent) {
          if (agent.id === this.currentAgentId) {
            throw new Error(
              "agent loop detected trying to redirect to the current active agent. if you are trying to redirect to another agent in a different project with the same name, you must specify the projectId parameter along with the name parameter"
            );
          }
          return new LocalAgentInvoker(
            this.port,
            agent.id,
            agent.name,
            this.projectId,
            agent.description
          );
        }
        const tracer = getTracer();
        const currentContext = context2.active();
        const span = tracer.startSpan("remoteagent.resolve", {}, currentContext);
        const spanContext = trace.setSpan(currentContext, span);
        return await context2.with(spanContext, async () => {
          if ("id" in params) {
            span.setAttribute("remote.agentId", params.id);
          }
          if ("name" in params) {
            span.setAttribute("remote.agentName", params.name);
          }
          try {
            const resp = await POST(
              "/agent/2025-03-17/resolve",
              safeStringify(params),
              {
                "Content-Type": "application/json"
              }
            );
            span.setAttribute("http.status_code", resp.status);
            if (resp.status === 404) {
              if ("id" in params) {
                span.setStatus({
                  code: SpanStatusCode2.ERROR,
                  message: `agent ${params.id} not found or you don't have access to it`
                });
                throw new Error(
                  `agent ${params.id} not found or you don't have access to it`
                );
              }
              if ("name" in params) {
                span.setStatus({
                  code: SpanStatusCode2.ERROR,
                  message: `agent ${params.name} not found or you don't have access to it`
                });
                throw new Error(
                  `agent ${params.name} not found or you don't have access to it`
                );
              }
              span.setStatus({
                code: SpanStatusCode2.ERROR,
                message: "agent not found or you don't have access to it"
              });
              throw new Error("agent not found or you don't have access to it");
            }
            const payload = resp.json;
            if (!payload?.success) {
              span.setStatus({
                code: SpanStatusCode2.ERROR,
                message: payload?.message ?? "unknown error from agent response"
              });
              throw new Error(
                payload?.message ?? "unknown error from agent response"
              );
            }
            span.setStatus({ code: SpanStatusCode2.OK });
            return new RemoteAgentInvoker(
              this.logger,
              payload.data.url,
              payload.data.authorization,
              payload.data.id,
              payload.data.name,
              payload.data.projectId,
              payload.data.orgId,
              payload.data.transactionId
            );
          } catch (ex) {
            recordException(span, ex);
            throw ex;
          } finally {
            span.end();
          }
        });
      }
    };
  }
});

// src/router/router.ts
import { AsyncLocalStorage } from "node:async_hooks";
import { ReadableStream as ReadableStream2 } from "node:stream/web";
import {
  SpanStatusCode as SpanStatusCode3,
  context as context3,
  trace as trace2,
  ValueType
} from "@opentelemetry/api";
function getTracer() {
  if (!globalTracer) {
    throw new Error("tracer not set");
  }
  return globalTracer;
}
function getSDKVersion() {
  if (!globalSDKVersion) {
    throw new Error("sdkVersion not set");
  }
  return globalSDKVersion;
}
function getAgentDetail() {
  const store = asyncStorage.getStore();
  if (!store) return null;
  const { logger: _logger, ...details } = store;
  return Object.keys(details).length > 0 ? details : null;
}
function recordException(span, ex, skipLog = false) {
  const __exception = ex;
  if (__exception?.__exception_recorded) {
    return;
  }
  if (!skipLog) {
    const store = asyncStorage.getStore();
    if (store?.logger) {
      store.logger.error("%s", ex);
    } else {
      console.error(ex);
    }
  }
  __exception.__exception_recorded = true;
  span.recordException(ex);
  span.setStatus({
    code: SpanStatusCode3.ERROR,
    message: ex.message
  });
}
async function agentRedirectRun(logger, config, fromAgent, remoteAgent, params) {
  const currentContext = context3.active();
  const span = config.context.tracer.startSpan(
    "agent.redirect",
    {
      attributes: {
        fromAgentName: fromAgent.name,
        fromAgentId: fromAgent.id,
        toAgentName: remoteAgent.name,
        toAgentId: remoteAgent.id
      }
    },
    currentContext
  );
  try {
    const spanContext = trace2.setSpan(currentContext, span);
    const agentDetail = {
      agentId: remoteAgent.id,
      agentName: remoteAgent.name,
      projectId: config.context.projectId,
      deploymentId: config.context.deploymentId,
      orgId: config.context.orgId,
      logger
    };
    return await asyncStorage.run(agentDetail, async () => {
      return await context3.with(spanContext, async () => {
        try {
          const res = await remoteAgent.run(...params);
          span.setStatus({ code: SpanStatusCode3.OK });
          return res;
        } catch (err) {
          recordException(span, err);
          throw err;
        }
      });
    });
  } finally {
    span.end();
  }
}
function createEmptyStream() {
  return new ReadableStream2({
    start(controller) {
      controller.close();
    }
  });
}
function createRouter(config) {
  const requests = config.context.meter.createCounter("requests", {
    description: "The number of requests to the agent",
    unit: "requests",
    valueType: ValueType.INT
  });
  let executingCount = 0;
  const executing = config.context.meter.createGauge("executing", {
    description: "The number of requests being processed",
    unit: "concurrent",
    valueType: ValueType.INT
  });
  globalTracer = config.context.tracer;
  globalMeter = config.context.meter;
  globalSDKVersion = config.context.sdkVersion;
  return async (req) => {
    const agentId = config.context.agent.id;
    let runId = req.request.runId;
    if (req.headers["x-agentuity-runid"]) {
      runId = req.headers["x-agentuity-runid"];
      if (runId) {
        delete req.headers["x-agentuity-runid"];
        if (req.request?.metadata?.["runid"] === runId) {
          delete req.request.metadata["runid"];
        }
      }
      req.request.runId = runId;
    }
    const logger = config.context.logger.child({
      "@agentuity/agentId": agentId,
      "@agentuity/agentName": config.context.agent.name
    });
    const resolver = new AgentResolver(
      logger,
      config.context.agents,
      config.port,
      config.context.projectId,
      agentId
    );
    const currentContext = context3.active();
    const span = config.context.tracer.startSpan(
      "agent.run",
      {
        attributes: {
          "@agentuity/agentName": config.context.agent.name,
          "@agentuity/agentId": agentId
        }
      },
      currentContext
    );
    try {
      const spanContext = trace2.setSpan(currentContext, span);
      if (!runId) {
        runId = span.spanContext().traceId;
        req.request.runId = runId;
      }
      executingCount++;
      requests.add(1, {
        "@agentuity/projectId": config.context.projectId,
        "@agentuity/deploymentId": config.context.deploymentId,
        "@agentuity/orgId": config.context.orgId
      });
      executing.record(executingCount, {
        "@agentuity/projectId": config.context.projectId,
        "@agentuity/deploymentId": config.context.deploymentId,
        "@agentuity/orgId": config.context.orgId
      });
      const agentDetail = {
        agentId: config.context.agent.id,
        agentName: config.context.agent.name,
        projectId: config.context.projectId,
        deploymentId: config.context.deploymentId,
        orgId: config.context.orgId,
        logger
      };
      return await asyncStorage.run(agentDetail, async () => {
        return await context3.with(spanContext, async () => {
          const body = req.body ? req.body : createEmptyStream();
          const request = new AgentRequestHandler(
            req.request.trigger,
            body,
            req.request.contentType,
            req.request.metadata ?? { headers: req.headers }
          );
          const response = new AgentResponseHandler();
          const contextObj = {
            ...config.context,
            logger,
            runId,
            getAgent: (params) => resolver.getAgent(params),
            scope: req.request.scope
          };
          try {
            let handlerResponse = await config.handler(
              request,
              response,
              contextObj
            );
            if (handlerResponse === void 0) {
              throw new Error(
                "handler returned undefined instead of a response"
              );
            }
            if (handlerResponse === null) {
              throw new Error("handler returned null instead of a response");
            }
            if (handlerResponse instanceof Response) {
              return await handlerResponse;
            }
            if (typeof handlerResponse === "string") {
              handlerResponse = await response.text(handlerResponse);
            } else if ("contentType" in handlerResponse && "payload" in handlerResponse) {
              const r = handlerResponse;
              handlerResponse = {
                data: r.data,
                metadata: r.metadata
              };
            } else if ("redirect" in handlerResponse && handlerResponse.redirect && "agent" in handlerResponse) {
              const redirect = handlerResponse;
              const agent = await contextObj.getAgent(redirect.agent);
              req.setTimeout(255);
              const redirectResponse = await agentRedirectRun(
                logger,
                config,
                config.context.agent,
                agent,
                [redirect.invocation ?? req.request]
              );
              span.setStatus({ code: SpanStatusCode3.OK });
              return redirectResponse;
            }
            span.setStatus({ code: SpanStatusCode3.OK });
            return handlerResponse;
          } catch (err) {
            recordException(span, err);
            throw err;
          }
        });
      });
    } finally {
      executingCount--;
      executing.record(executingCount, {
        "@agentuity/projectId": config.context.projectId,
        "@agentuity/deploymentId": config.context.deploymentId,
        "@agentuity/orgId": config.context.orgId
      });
      span.end();
    }
  };
}
var asyncStorage, globalTracer, globalMeter, globalSDKVersion;
var init_router = __esm({
  "src/router/router.ts"() {
    "use strict";
    init_request();
    init_response();
    init_agents();
    asyncStorage = new AsyncLocalStorage();
  }
});

// src/apis/api.ts
async function send(request, forceBuffer = false, attempt = 1) {
  const apiKey = request.authToken ?? (process.env.AGENTUITY_SDK_KEY || process.env.AGENTUITY_API_KEY);
  if (!apiKey) {
    throw new Error("AGENTUITY_API_KEY or AGENTUITY_SDK_KEY is not set");
  }
  const url = "path" in request ? new URL(
    request.path,
    process.env.AGENTUITY_TRANSPORT_URL || "https://agentuity.ai/"
  ) : new URL(request.url);
  const sdkVersion = getSDKVersion();
  const headers = {
    Accept: "application/json",
    "Content-Type": "application/json",
    "User-Agent": `Agentuity JS SDK/${sdkVersion}`
  };
  for (const key in request.headers) {
    headers[key] = request.headers[key];
  }
  headers.Authorization = `Bearer ${apiKey}`;
  const resp = await apiFetch(url, {
    method: request.method,
    body: request.body,
    headers,
    keepalive: true,
    signal: AbortSignal.timeout(request.timeout || 2e4)
  });
  let json = null;
  switch (resp.status) {
    case 429: {
      if (attempt < 3) {
        const wait = 250 * 2 ** attempt;
        await sleep(wait);
        return send(request, forceBuffer, attempt + 1);
      }
      break;
    }
    case 200:
    case 201:
    case 202: {
      if (!forceBuffer) {
        const contentType = resp.headers.get("content-type");
        if (contentType?.includes("/json")) {
          json = await resp.json();
        }
      }
      break;
    }
    default:
      break;
  }
  return {
    json,
    headers: resp.headers,
    status: resp.status,
    response: resp
  };
}
async function GET(path, forceBuffer, headers, timeout) {
  return send(
    {
      method: "GET",
      path,
      headers,
      timeout
    },
    forceBuffer
  );
}
async function POST(path, body, headers, timeout, authToken) {
  return send({
    method: "POST",
    path,
    body,
    headers,
    timeout,
    authToken
  });
}
async function PUT(path, body, headers, timeout) {
  return send({
    method: "PUT",
    path,
    body,
    timeout,
    headers
  });
}
async function DELETE(path, body, headers, timeout) {
  return send({
    method: "DELETE",
    path,
    body,
    timeout,
    headers
  });
}
var apiFetch, sleep;
var init_api = __esm({
  "src/apis/api.ts"() {
    "use strict";
    init_router();
    apiFetch = globalThis.fetch;
    sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  }
});

// src/io/email.ts
import { simpleParser } from "mailparser";
import { inspect } from "node:util";
import MailComposer from "nodemailer/lib/mail-composer";
import { context as context4, trace as trace3, SpanStatusCode as SpanStatusCode4 } from "@opentelemetry/api";
async function parseEmail(data) {
  try {
    const message = await simpleParser(data);
    return new Email(message);
  } catch (error) {
    throw new Error(
      `Failed to parse email: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
var RemoteEmailAttachment, Email;
var init_email = __esm({
  "src/io/email.ts"() {
    "use strict";
    init_util();
    init_data();
    init_api();
    init_router();
    RemoteEmailAttachment = class {
      filename;
      contentDisposition;
      _url;
      constructor(filename, url, contentDisposition) {
        this.filename = filename;
        this.contentDisposition = contentDisposition ?? "attachment";
        this._url = url;
      }
      async data() {
        const tracer = getTracer();
        const currentContext = context4.active();
        const span = tracer.startSpan(
          "agentuity.email.attachment",
          {},
          currentContext
        );
        try {
          const spanContext = trace3.setSpan(currentContext, span);
          return await context4.with(spanContext, async () => {
            const res = await send({ url: this._url, method: "GET" }, true);
            if (res.status === 200) {
              span.setStatus({ code: SpanStatusCode4.OK });
              return new DataHandler(
                res.response.body,
                res.headers.get("content-type") ?? "application/octet-stream"
              );
            }
            throw new Error(`Failed to fetch attachment: ${res.status}`);
          });
        } catch (ex) {
          recordException(span, ex);
          throw ex;
        } finally {
          span.end();
        }
      }
    };
    Email = class {
      _message;
      constructor(data) {
        this._message = data;
      }
      [inspect.custom]() {
        return this.toString();
      }
      toString() {
        return `[Email id=${this.messageId()},from=${this.fromEmail()},subject=${this.subject()}]`;
      }
      /**
       * The date of the email.
       */
      date() {
        return this._message.date ?? null;
      }
      /**
       * The message ID of the email.
       */
      messageId() {
        return this._message.messageId ?? null;
      }
      /**
       * The headers of the email.
       */
      headers() {
        return this._message.headers;
      }
      /**
       * The email address of the recipient or null if there is no recipient.
       *
       * If the email has multiple recipients, the email addresses are comma separated.
       */
      to() {
        if (!this._message.to) {
          return null;
        }
        if (Array.isArray(this._message.to)) {
          return this._message.to.map((addr) => addr.text.trim()).join(", ");
        }
        if (typeof this._message.to === "object" && "text" in this._message.to) {
          return this._message.to.text;
        }
        return null;
      }
      /**
       * The email address of the sender or null if there is no sender.
       */
      fromEmail() {
        return this._message.from?.value[0]?.address ?? null;
      }
      /**
       * The name of the sender or null if there is no name.
       */
      fromName() {
        return this._message.from?.value[0]?.name ?? null;
      }
      /**
       * The subject of the email or null if there is no subject.
       */
      subject() {
        return this._message.subject ?? null;
      }
      /**
       * The plain text body of the email or null if there is no plain text body.
       */
      text() {
        return this._message.text ?? null;
      }
      /**
       * The HTML body of the email or null if there is no HTML body.
       */
      html() {
        return this._message.html ? this._message.html : null;
      }
      /**
       * The attachments of the email or an empty array if there are no attachments.
       */
      attachments() {
        if (!this._message.attachments || this._message.attachments.length === 0) {
          return [];
        }
        return this._message.attachments.map((att) => {
          const hv = att.headers.get("content-disposition");
          if (!hv || !hv.params) {
            throw new Error(
              "Invalid attachment headers: missing content-disposition"
            );
          }
          if (!hv.params.filename || !hv.params.url) {
            throw new Error("Invalid attachment headers: missing filename or url");
          }
          return new RemoteEmailAttachment(
            hv.params.filename,
            hv.params.url,
            hv.value
          );
        });
      }
      makeReplySubject(subject) {
        if (subject) {
          return subject;
        }
        const _subject = this.subject();
        if (_subject) {
          if (_subject.toUpperCase().startsWith("RE:")) {
            return _subject;
          }
          return `RE: ${_subject}`;
        }
        return "";
      }
      /**
       * send a reply to the email
       */
      async sendReply(req, context12, reply) {
        const authToken = req.metadata?.["email-auth-token"];
        if (!authToken) {
          throw new Error(
            "email authorization token is required but not found in metadata"
          );
        }
        return new Promise(async (resolve, reject) => {
          try {
            let attachments = [];
            if (reply.attachments) {
              attachments = await Promise.all(
                reply.attachments.map(async (attachment) => {
                  const resp = await fromDataType(attachment.data);
                  return {
                    filename: attachment.filename,
                    content: await resp.data.buffer(),
                    contentType: resp.data.contentType,
                    contentDisposition: attachment.contentDisposition ?? "attachment"
                  };
                })
              );
            }
            const mail = new MailComposer({
              inReplyTo: this.messageId() ?? void 0,
              references: this.messageId() ?? void 0,
              date: /* @__PURE__ */ new Date(),
              from: {
                name: context12.agent.name,
                address: this.to()
              },
              to: {
                name: this.fromName() ?? void 0,
                address: this.fromEmail() ?? void 0
              },
              subject: this.makeReplySubject(reply.subject),
              text: reply.text,
              html: reply.html,
              attachments
            });
            const newemail = mail.compile();
            newemail.build(async (err, message) => {
              if (err) {
                reject(err);
              } else {
                try {
                  await context12.email.sendReply(
                    context12.agent.id,
                    message.toString(),
                    authToken,
                    newemail.messageId()
                  );
                  resolve(newemail.messageId());
                } catch (ex) {
                  reject(ex);
                }
              }
            });
          } catch (ex) {
            reject(ex);
          }
        });
      }
    };
  }
});

// src/router/data.ts
import { ReadableStream as ReadableStream3 } from "node:stream/web";
var invalidJsonSymbol, chunkingRegexp, chunkSmoothing, sleep2, toBuffer, DataHandler;
var init_data = __esm({
  "src/router/data.ts"() {
    "use strict";
    init_util();
    init_email();
    invalidJsonSymbol = Symbol("invalid json");
    chunkingRegexp = {
      word: /\S+\s+/m,
      line: /\n+/m
    };
    chunkSmoothing = 10;
    sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    toBuffer = async (buffer, value) => {
      if (value instanceof Uint8Array) {
        return Buffer.concat([buffer, value]);
      }
      if (value instanceof ArrayBuffer) {
        return Buffer.concat([buffer, Buffer.from(value)]);
      }
      if (value instanceof Blob) {
        const buf = await value.arrayBuffer();
        return Buffer.concat([buffer, Buffer.from(buf)]);
      }
      if (typeof value === "string") {
        return Buffer.concat([buffer, Buffer.from(value)]);
      }
      throw new Error(`Unsupported value type: ${typeof value}`);
    };
    DataHandler = class {
      _type;
      _readstream;
      _buffer;
      _email;
      constructor(stream, contentType) {
        this._type = contentType ?? "application/octet-stream";
        if (typeof stream === "string") {
          this._buffer = Buffer.from(stream);
        } else if (stream instanceof Buffer) {
          this._buffer = stream;
        } else {
          this._readstream = stream;
          this._buffer = Buffer.alloc(0);
        }
      }
      async ensureStreamLoaded() {
        if (this._buffer.length === 0 && this._readstream) {
          let buffer = Buffer.alloc(0);
          if (this._readstream instanceof ReadableStream3) {
            const reader = this._readstream.getReader();
            while (true) {
              const { done, value } = await reader.read();
              if (value) {
                buffer = await toBuffer(buffer, value);
              }
              if (done) {
                break;
              }
            }
          } else {
            for await (const chunk of this._readstream) {
              buffer = await toBuffer(buffer, chunk);
            }
          }
          this._buffer = buffer;
          this._readstream = void 0;
        }
        return this._buffer;
      }
      toString() {
        return `[Data ${this._type}]`;
      }
      async data() {
        return this.ensureStreamLoaded();
      }
      get contentType() {
        return this._type;
      }
      async base64() {
        const data = await this.data();
        return data.toString("base64");
      }
      async text() {
        const data = await this.data();
        if (!data || data.length === 0) {
          return "";
        }
        return data.toString("utf-8");
      }
      async json() {
        const text = await this.text();
        if (!text || text.trim() === "") {
          throw new Error("Cannot parse empty JSON");
        }
        const res = safeParse(text, invalidJsonSymbol);
        if (res === invalidJsonSymbol) {
          throw new Error("The content type is not valid JSON");
        }
        return res;
      }
      async object() {
        try {
          const res = await this.json();
          return res;
        } catch (error) {
          throw new Error(
            `Failed to parse object: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }
      async binary() {
        const data = await this.data();
        return new Uint8Array(data);
      }
      async blob() {
        const data = await this.data();
        return new Blob([data], { type: this.contentType });
      }
      async arrayBuffer() {
        const data = await this.data();
        return data.buffer;
      }
      async stream() {
        if (this._readstream) {
          if (this._readstream instanceof ReadableStream3) {
            return this._readstream;
          }
          const iterator = this._readstream;
          return new ReadableStream3({
            async start(controller) {
              for await (const chunk of iterator) {
                controller.enqueue(chunk);
              }
              controller.close();
            }
          });
        }
        const dataPromise = this.data();
        const chunkable = this.isTextChunkable();
        const contentType = this.contentType;
        return new ReadableStream3({
          async start(controller) {
            const data = await dataPromise;
            if (!chunkable) {
              controller.enqueue(data);
              controller.close();
              return;
            }
            const chunkby = contentType.startsWith("text/") ? "word" : "line";
            const re = chunkingRegexp[chunkby];
            let match;
            let buffer = data.toString("utf-8");
            match = re.exec(buffer);
            while (match !== null) {
              const chunk = match[0];
              controller.enqueue(Buffer.from(chunk));
              buffer = buffer.slice(chunk.length);
              match = re.exec(buffer);
              if (!match) {
                break;
              }
              await sleep2(chunkSmoothing);
            }
            if (buffer.length > 0) {
              controller.enqueue(Buffer.from(buffer));
            }
            controller.close();
          }
        });
      }
      async email() {
        if (this.contentType !== "message/rfc822") {
          throw new Error("The content type is not a valid email");
        }
        if (this._email) {
          return this._email;
        }
        const data = await this.data();
        this._email = await parseEmail(data);
        return this._email;
      }
      isTextChunkable() {
        return this.contentType.startsWith("text/") || this.contentType === "application/json";
      }
      async buffer() {
        return this.data();
      }
    };
  }
});

// src/router/request.ts
var AgentRequestHandler;
var init_request = __esm({
  "src/router/request.ts"() {
    "use strict";
    init_data();
    AgentRequestHandler = class {
      _trigger;
      _datahandler;
      _metadata;
      /**
       * constructor
       *
       * @param trigger - The trigger of the request
       * @param stream - The stream of the request
       * @param contentType - The content type of the request
       * @param metadata - The metadata of the request
       */
      constructor(trigger, stream, contentType, metadata) {
        this._trigger = trigger;
        this._datahandler = new DataHandler(stream, contentType);
        this._metadata = metadata;
      }
      /**
       * get the trigger of the request
       */
      get trigger() {
        return this._trigger;
      }
      /**
       * get the data of the request
       */
      get data() {
        return this._datahandler;
      }
      /**
       * get the metadata object of the request
       */
      get metadata() {
        return this._metadata;
      }
      /**
       * get the metadata value of the request
       */
      get(key, defaultValue) {
        const metadata = this._metadata;
        if (key in metadata) {
          return metadata[key];
        }
        return defaultValue ?? null;
      }
    };
  }
});

// src/server/bun.ts
var bun_exports = {};
__export(bun_exports, {
  BunServer: () => BunServer
});
import { context as context9, trace as trace8, SpanKind, SpanStatusCode as SpanStatusCode9 } from "@opentelemetry/api";
var idleTimeout, BunServer;
var init_bun = __esm({
  "src/server/bun.ts"() {
    "use strict";
    init_otel();
    init_util();
    idleTimeout = 255;
    BunServer = class {
      server = null;
      config;
      /**
       * Creates a new Bun server
       *
       * @param config - The server configuration
       */
      constructor(config) {
        this.config = config;
      }
      /**
       * Starts the server
       *
       * @throws Error if the server is already running
       */
      async start() {
        if (this.server) {
          throw new Error("Server is already running");
        }
        const routeMap = /* @__PURE__ */ new Map();
        for (const route of this.config.routes) {
          const key = `${route.method}:${route.path}`;
          routeMap.set(key, route);
        }
        let theserver = null;
        const devmode2 = process.env.AGENTUITY_SDK_DEV_MODE === "true";
        const { sdkVersion, logger } = this.config;
        const hostname = process.env.AGENTUITY_ENV === "development" ? "127.0.0.1" : "0.0.0.0";
        this.server = theserver = Bun.serve({
          port: this.config.port,
          hostname,
          idleTimeout,
          routes: {
            "/": {
              GET: async (req) => {
                const helpText = getRoutesHelpText(
                  req.headers.get("host") ?? "127.0.0.1:3500",
                  this.config.routes
                );
                return new Response(helpText, {
                  headers: {
                    "Content-Type": "text/plain"
                  }
                });
              }
            },
            "/_health": new Response("OK", {
              headers: {
                "x-agentuity-version": sdkVersion
              }
            }),
            "/welcome": {
              GET: async () => {
                const result = {};
                for (const route of this.config.routes) {
                  if (route.welcome) {
                    let r = route.welcome();
                    if (r instanceof Promise) {
                      r = await r;
                    }
                    if (r.prompts) {
                      for (let c = 0; c < r.prompts.length; c++) {
                        const p = r.prompts[c];
                        r.prompts[c] = await toWelcomePrompt(p);
                      }
                    }
                    result[route.agent.id] = r;
                  }
                }
                return new Response(JSON.stringify(result), {
                  headers: {
                    "Content-Type": "application/json"
                  }
                });
              }
            },
            "/welcome/:id": {
              GET: async (req) => {
                const url = new URL(req.url);
                const id = url.pathname.slice(5);
                for (const route of this.config.routes) {
                  if (route.agent.id === id && route.welcome) {
                    let r = route.welcome();
                    if (r instanceof Promise) {
                      r = await r;
                    }
                    if (r.prompts) {
                      for (let c = 0; c < r.prompts.length; c++) {
                        const p = r.prompts[c];
                        r.prompts[c] = await toWelcomePrompt(p);
                      }
                    }
                    return new Response(JSON.stringify(r), {
                      headers: {
                        "Content-Type": "application/json"
                      }
                    });
                  }
                }
                return new Response("Not Found", {
                  status: 404
                });
              }
            }
          },
          async fetch(req) {
            const method = req.method;
            if (method === "OPTIONS") {
              return new Response("OK", {
                headers: {
                  "Access-Control-Allow-Origin": "*",
                  "Access-Control-Allow-Methods": "GET, PUT, DELETE, PATCH, OPTIONS, POST",
                  "Access-Control-Allow-Headers": "Content-Type, Authorization"
                }
              });
            }
            theserver?.timeout(req, 0);
            const url = new URL(req.url);
            const extractedContext = extractTraceContextFromBunRequest(req);
            return context9.with(extractedContext, async () => {
              return trace8.getTracer("http-server").startActiveSpan(
                `HTTP ${method}`,
                {
                  kind: SpanKind.SERVER,
                  attributes: {
                    "http.method": method,
                    "http.url": req.url,
                    "http.host": url.host,
                    "http.user_agent": req.headers.get("user-agent") || "",
                    "http.path": url.pathname
                  }
                },
                async (span) => {
                  try {
                    const agentId = url.pathname.split("/")[1];
                    const routeKey = `POST:/${agentId}`;
                    const route = routeMap.get(routeKey);
                    if (!route) {
                      if (method === "GET" && shouldIgnoreStaticFile(url.pathname)) {
                        span.setAttribute("http.status_code", "404");
                        return new Response("Not Found", {
                          status: 404,
                          headers: injectTraceContextToHeaders()
                        });
                      }
                      logger.error(
                        "agent not found: %s for: %s",
                        method,
                        url.pathname
                      );
                      span.setStatus({
                        code: SpanStatusCode9.ERROR,
                        message: `No Agent found at ${url.pathname}`
                      });
                      return new Response("Not Found", {
                        status: 404,
                        headers: injectTraceContextToHeaders()
                      });
                    }
                    span.setAttribute("@agentuity/agentName", route.agent.name);
                    span.setAttribute("@agentuity/agentId", route.agent.id);
                    logger.debug("request: %s %s", method, url.pathname);
                    const runId = span.spanContext().traceId;
                    try {
                      const routeResult = route.handler({
                        body: req.body ?? void 0,
                        url: req.url,
                        headers: req.headers.toJSON(),
                        request: getRequestFromHeaders(req.headers.toJSON(), runId),
                        setTimeout: (val) => void 0
                      });
                      return createStreamingResponse(
                        req.headers.get("origin"),
                        `Agentuity BunJS/${sdkVersion}`,
                        span,
                        routeResult
                      );
                    } catch (error) {
                      span.recordException(error);
                      span.setStatus({
                        code: SpanStatusCode9.ERROR,
                        message: error.message
                      });
                      span.setAttribute("http.status_code", "500");
                      return new Response("Internal Server Error", {
                        status: 500,
                        headers: injectTraceContextToHeaders()
                      });
                    }
                  } finally {
                    span.end();
                  }
                }
              );
            });
          },
          error(error) {
            const { stack, message } = error;
            let errorMessage = message;
            if (devmode2) {
              errorMessage = stack ?? errorMessage;
            }
            return new Response(errorMessage, {
              status: 500,
              headers: {
                "Content-Type": "text/plain"
              }
            });
          }
        });
        this.config.logger.info("Bun server started on port %d", this.config.port);
      }
      /**
       * Stops the server
       */
      async stop() {
        if (!this.server) {
          return;
        }
        const server = this.server;
        this.server = null;
        this.config.logger.debug("server stopping");
        await server.stop();
        this.config.logger.info("server stopped");
      }
    };
  }
});

// src/server/node.ts
var node_exports = {};
__export(node_exports, {
  MAX_REQUEST_TIMEOUT: () => MAX_REQUEST_TIMEOUT,
  NodeServer: () => NodeServer
});
import {
  createServer as createHttpServer
} from "node:http";
import { context as context10, trace as trace9, SpanKind as SpanKind2, SpanStatusCode as SpanStatusCode10 } from "@opentelemetry/api";
import { Readable } from "node:stream";
var MAX_REQUEST_TIMEOUT, NodeServer;
var init_node = __esm({
  "src/server/node.ts"() {
    "use strict";
    init_otel();
    init_util();
    MAX_REQUEST_TIMEOUT = 6e4 * 10;
    NodeServer = class {
      logger;
      port;
      routes;
      server = null;
      sdkVersion;
      /**
       * Creates a new Node.js server
       *
       * @param config - The server configuration
       */
      constructor({ logger, port, routes, sdkVersion }) {
        this.logger = logger;
        this.port = port;
        this.routes = routes;
        this.sdkVersion = sdkVersion;
      }
      /**
       * Stops the server
       */
      async stop() {
        return new Promise((resolve, reject) => {
          if (this.server) {
            const server = this.server;
            this.server = null;
            server.close((err) => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            });
          }
        });
      }
      getBufferAsStream(req) {
        return new Promise((resolve, reject) => {
          const chunks = [];
          req.on("data", (chunk) => chunks.push(chunk));
          req.on("end", async () => {
            const body = Buffer.concat(chunks);
            const readable = Readable.from(body);
            resolve(Readable.toWeb(readable));
          });
          req.on("error", (err) => {
            reject(err);
          });
        });
      }
      /**
       * Gets the headers from the request
       */
      getHeaders(req) {
        const headers = {};
        for (const [key, value] of Object.entries(req.headers)) {
          if (typeof value === "string") {
            headers[key] = value;
          } else if (Array.isArray(value)) {
            headers[key] = value[0] || "";
          }
        }
        return headers;
      }
      /**
       * Starts the server
       */
      async start() {
        const { sdkVersion } = this;
        const devmode2 = process.env.AGENTUITY_SDK_DEV_MODE === "true";
        this.server = createHttpServer(async (req, res) => {
          if (req.method === "GET" && req.url === "/_health") {
            res.writeHead(200, {
              "x-agentuity-version": sdkVersion
            });
            res.end();
            return;
          }
          if (req.method === "GET" && req.url === "/") {
            res.writeHead(200, {
              "Content-Type": "text/plain"
            });
            res.end(
              getRoutesHelpText(req.headers.host ?? "127.0.0.1:3500", this.routes)
            );
            return;
          }
          if (req.method === "OPTIONS") {
            res.writeHead(200, {
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "GET, PUT, DELETE, PATCH, OPTIONS, POST",
              "Access-Control-Allow-Headers": "Content-Type, Authorization"
            });
            res.end();
            return;
          }
          if (req.method === "GET" && req.url === "/welcome") {
            const result = {};
            for (const route of this.routes) {
              if (route.welcome) {
                let r = route.welcome();
                if (r instanceof Promise) {
                  r = await r;
                }
                if (r.prompts) {
                  for (let c = 0; c < r.prompts.length; c++) {
                    const p = r.prompts[c];
                    r.prompts[c] = await toWelcomePrompt(p);
                  }
                }
                result[route.agent.id] = r;
              }
            }
            res.writeHead(200, {
              "Content-Type": "application/json"
            });
            res.end(safeStringify(result));
            return;
          }
          if (req.method === "GET" && req.url === "/welcome/") {
            let content = null;
            for (const route of this.routes) {
              if (route.welcome) {
                let r = route.welcome();
                if (r instanceof Promise) {
                  r = await r;
                }
                if (r.prompts) {
                  for (let c = 0; c < r.prompts.length; c++) {
                    const p = r.prompts[c];
                    r.prompts[c] = await toWelcomePrompt(p);
                  }
                }
                content = r;
                break;
              }
            }
            if (content) {
              res.writeHead(200, {
                "Content-Type": "application/json"
              });
              res.end(JSON.stringify(content));
              return;
            }
            res.writeHead(404);
            res.end();
          }
          const extractedContext = extractTraceContextFromNodeRequest(req);
          await context10.with(extractedContext, async () => {
            await trace9.getTracer("http-server").startActiveSpan(
              `HTTP ${req.method}`,
              {
                kind: SpanKind2.SERVER,
                attributes: {
                  "http.method": req.method || "UNKNOWN",
                  "http.path": req.url,
                  "http.url": req.url || "",
                  // FIXME should be full url
                  "http.host": req.headers.host || "",
                  "http.user_agent": req.headers["user-agent"] || ""
                }
              },
              async (span) => {
                try {
                  const route = this.routes.find((r) => r.path === req.url);
                  if (!route) {
                    if (req.method === "GET" && shouldIgnoreStaticFile(req.url ?? "/")) {
                      span.setAttribute("http.status_code", "404");
                      res.writeHead(404, injectTraceContextToHeaders());
                      res.end();
                      return;
                    }
                    this.logger.error(
                      "agent not found: %s for: %s",
                      req.method,
                      req.url
                    );
                    span.setAttribute("http.status_code", "404");
                    res.writeHead(404, injectTraceContextToHeaders());
                    res.end();
                    span.setStatus({
                      code: SpanStatusCode10.ERROR,
                      message: `No Agent found at ${req.url}`
                    });
                    return;
                  }
                  if (req.method !== route.method) {
                    this.logger.error(
                      "unsupported method: %s for: %s",
                      req.method,
                      req.url
                    );
                    span.setAttribute("http.status_code", "405");
                    res.writeHead(405, injectTraceContextToHeaders());
                    res.end();
                    span.setStatus({
                      code: SpanStatusCode10.ERROR,
                      message: `Method not allowed: ${req.method} ${req.url}`
                    });
                    return;
                  }
                  span.setAttribute("@agentuity/agentName", route.agent.name);
                  span.setAttribute("@agentuity/agentId", route.agent.id);
                  const runId = span.spanContext().traceId;
                  this.logger.debug("request: %s %s", req.method, req.url);
                  try {
                    const agentReq = {
                      body: await this.getBufferAsStream(req),
                      request: getRequestFromHeaders(
                        req.headers,
                        runId
                      ),
                      url: req.url ?? "",
                      headers: this.getHeaders(req),
                      setTimeout: (val) => req.setTimeout(val)
                    };
                    const routeResult = route.handler(agentReq);
                    const response = await createStreamingResponse(
                      req.headers.origin ?? null,
                      `Agentuity NodeJS/${sdkVersion}`,
                      span,
                      routeResult
                    );
                    const outheaders = {};
                    const headers = response.headers;
                    headers.forEach((value, key) => {
                      outheaders[key] = value;
                    });
                    res.writeHead(response.status, outheaders);
                    res.flushHeaders();
                    if (response.body) {
                      const reader = response.body.getReader();
                      while (true) {
                        const { done, value } = await reader.read();
                        if (value) {
                          res.write(value);
                        }
                        if (done) {
                          break;
                        }
                      }
                    }
                    res.end();
                  } catch (err) {
                    this.logger.error("Server error", err);
                    try {
                      injectTraceContextToNodeResponse(res);
                    } catch (err2) {
                      this.logger.error("Error injecting trace context: %s", err2);
                    }
                    res.setHeader("Content-Type", "text/plain");
                    res.writeHead(500);
                    const { stack, message } = err;
                    let errorMessage = message;
                    if (devmode2) {
                      errorMessage = stack ?? errorMessage;
                    }
                    res.end(errorMessage);
                    span.recordException(err);
                    span.setAttribute("http.status_code", "500");
                    span.setStatus({
                      code: SpanStatusCode10.ERROR,
                      message: err.message
                    });
                  }
                } finally {
                  span.end();
                }
              }
            );
          });
        });
        return new Promise((resolve) => {
          const server = this.server;
          server.requestTimeout = MAX_REQUEST_TIMEOUT;
          server.timeout = MAX_REQUEST_TIMEOUT;
          const address = process.env.AGENTUITY_ENV === "development" ? "127.0.0.1" : "0.0.0.0";
          server.listen(this.port, address, () => {
            this.logger.info(`Node server listening on port ${this.port}`);
            resolve();
          });
        });
      }
    };
  }
});

// src/server/server.ts
import { join } from "node:path";
import { existsSync } from "node:fs";

// src/apis/keyvalue.ts
init_types();
init_api();
init_router();
init_util();
init_data();
import { context as context5, trace as trace4, SpanStatusCode as SpanStatusCode5 } from "@opentelemetry/api";

// src/server/gzip.ts
import { gzip, gunzip } from "node:zlib";
import { promisify } from "node:util";
var gzipPromise = promisify(gzip);
var gunzipPromise = promisify(gunzip);
async function gzipBuffer(buffer) {
  if (buffer.length === 0) {
    return buffer;
  }
  return gzipPromise(buffer);
}
async function gunzipBuffer(buffer) {
  if (!buffer || buffer.length === 0) {
    return Buffer.alloc(0);
  }
  if (buffer.length >= 2 && buffer[0] === 31 && buffer[1] === 139) {
    return gunzipPromise(buffer);
  }
  return buffer;
}

// src/apis/keyvalue.ts
var KeyValueAPI = class {
  /**
   * get a value from the key value storage
   *
   * @param name - the name of the key value storage
   * @param key - the key to get the value of
   * @returns the value of the key
   */
  async get(name, key) {
    const tracer = getTracer();
    const currentContext = context5.active();
    const span = tracer.startSpan("agentuity.keyvalue.get", {}, currentContext);
    try {
      span.setAttribute("name", name);
      span.setAttribute("key", key);
      const spanContext = trace4.setSpan(currentContext, span);
      return await context5.with(spanContext, async () => {
        const resp = await GET(
          `/kv/2025-03-17/${encodeURIComponent(name)}/${encodeURIComponent(key)}`,
          true
        );
        if (resp.status === 404) {
          span.addEvent("miss");
          span.setStatus({ code: SpanStatusCode5.OK });
          return { exists: false };
        }
        if (resp.status === 200) {
          span.addEvent("hit");
          let body = Buffer.from(await resp.response.arrayBuffer());
          if (resp.headers.get("content-encoding") === "gzip") {
            body = await gunzipBuffer(body);
          }
          const result = {
            exists: true,
            data: new DataHandler(
              body,
              resp.headers.get("content-type") ?? "application/octet-stream"
            )
          };
          span.setStatus({ code: SpanStatusCode5.OK });
          return result;
        }
        throw new Error(
          `error getting keyvalue: ${resp.response.statusText} (${resp.response.status})`
        );
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
  /**
   * set a value in the key value storage
   *
   * @param name - the name of the key value storage
   * @param key - the key to set the value of
   * @param value - the value to set
   * @param ttl - the time to live of the key
   */
  async set(name, key, value, params) {
    if (!isDataType(value)) {
      throw new Error("value must be a DataType");
    }
    const tracer = getTracer();
    const currentContext = context5.active();
    const span = tracer.startSpan("agentuity.keyvalue.set", {}, currentContext);
    try {
      span.setAttribute("name", name);
      span.setAttribute("key", key);
      if (params?.ttl) {
        span.setAttribute("ttl", params.ttl);
      }
      if (params?.contentType) {
        span.setAttribute("contentType", params.contentType);
      }
      const spanContext = trace4.setSpan(currentContext, span);
      await context5.with(spanContext, async () => {
        const datavalue = await fromDataType(value, params?.contentType);
        let ttlstr = "";
        if (params?.ttl) {
          if (params.ttl < 60) {
            throw new Error(
              `ttl for keyvalue set must be at least 60 seconds, got ${params.ttl}`
            );
          }
          ttlstr = `/${params.ttl}`;
        }
        let buffer;
        const headers = {
          "Content-Type": datavalue.data.contentType
        };
        if (datavalue.data.contentType.includes("text") || datavalue.data.contentType.includes("json")) {
          const compressed = await gzipBuffer(await datavalue.data.buffer());
          buffer = compressed;
          headers["Content-Encoding"] = "gzip";
        } else {
          buffer = await datavalue.data.buffer();
        }
        const resp = await PUT(
          `/kv/2025-03-17/${encodeURIComponent(name)}/${encodeURIComponent(key)}${ttlstr}`,
          new Blob([buffer], {
            type: datavalue.data.contentType
          }),
          headers
        );
        if (resp.status !== 201) {
          throw new Error(
            `error setting keyvalue: ${resp.response.statusText} (${resp.response.status})`
          );
        }
        span.setStatus({ code: SpanStatusCode5.OK });
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
  /**
   * delete a value from the key value storage
   *
   * @param name - the name of the key value storage
   * @param key - the key to delete
   */
  async delete(name, key) {
    const tracer = getTracer();
    const currentContext = context5.active();
    const span = tracer.startSpan(
      "agentuity.keyvalue.delete",
      {},
      currentContext
    );
    try {
      span.setAttribute("name", name);
      span.setAttribute("key", key);
      const spanContext = trace4.setSpan(currentContext, span);
      await context5.with(spanContext, async () => {
        const resp = await DELETE(
          `/kv/2025-03-17/${encodeURIComponent(name)}/${encodeURIComponent(key)}`
        );
        if (resp.status !== 200) {
          throw new Error(
            `error deleting keyvalue: ${resp.response.statusText} (${resp.response.status})`
          );
        }
        span.setStatus({ code: SpanStatusCode5.OK });
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
};

// src/apis/vector.ts
init_types();
init_api();
init_router();
init_util();
import { context as context6, trace as trace5, SpanStatusCode as SpanStatusCode6 } from "@opentelemetry/api";
var VectorAPI = class {
  /**
   * upsert a vector into the vector storage
   *
   * @param name - the name of the vector storage
   * @param documents - the documents for the vector upsert
   * @returns the ids of the vectors that were upserted
   */
  async upsert(name, ...documents) {
    const tracer = getTracer();
    const currentContext = context6.active();
    const span = tracer.startSpan(
      "agentuity.vector.upsert",
      { attributes: { name } },
      currentContext
    );
    try {
      const spanContext = trace5.setSpan(currentContext, span);
      return await context6.with(spanContext, async () => {
        const resp = await PUT(
          `/vector/2025-03-17/${encodeURIComponent(name)}`,
          safeStringify(documents)
        );
        if (resp.status === 200) {
          if (resp.json?.success) {
            const json = resp.json;
            span.setStatus({ code: SpanStatusCode6.OK });
            return json.data.map((o) => o.id);
          }
        }
        if (!resp.json?.success && resp.json?.message) {
          throw new Error(resp.json.message);
        }
        throw new Error("unknown error");
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
  /**
   * get a vector from the vector storage by key
   *
   * @param name - the name of the vector storage
   * @param key - the key of the vector to get
   * @returns the result of the vector search
   */
  async get(name, key) {
    const tracer = getTracer();
    const currentContext = context6.active();
    const span = tracer.startSpan(
      "agentuity.vector.get",
      { attributes: { name } },
      currentContext
    );
    try {
      const spanContext = trace5.setSpan(currentContext, span);
      return await context6.with(spanContext, async () => {
        const resp = await GET(
          `/vector/2025-03-17/${encodeURIComponent(name)}/${encodeURIComponent(key)}`
        );
        if (resp.status === 404) {
          span.addEvent("miss");
          span.setStatus({ code: SpanStatusCode6.OK });
          return null;
        }
        if (resp.status === 200) {
          if (resp.json?.success) {
            span.addEvent("hit");
            span.setStatus({ code: SpanStatusCode6.OK });
            return resp.json.data;
          }
        }
        if (!resp.json?.success && resp.json?.message) {
          throw new Error(resp.json.message);
        }
        throw new Error("unknown error");
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
  /**
   * search for vectors in the vector storage
   *
   * @param name - the name of the vector storage
   * @param params - the parameters for the vector search
   * @returns the results of the vector search
   */
  async search(name, params) {
    if (!isJsonObject(params.metadata)) {
      throw new Error("params.metadata must be a JsonObject");
    }
    const tracer = getTracer();
    const currentContext = context6.active();
    const span = tracer.startSpan(
      "agentuity.vector.search",
      {
        attributes: {
          name,
          query: params.query,
          limit: params.limit,
          similarity: params.similarity
        }
      },
      currentContext
    );
    try {
      const spanContext = trace5.setSpan(currentContext, span);
      return await context6.with(spanContext, async () => {
        const resp = await POST(
          `/vector/2025-03-17/search/${encodeURIComponent(name)}`,
          safeStringify(params)
        );
        if (resp.status === 404) {
          span.addEvent("miss");
          span.setStatus({ code: SpanStatusCode6.OK });
          return [];
        }
        if (resp.status === 200) {
          if (resp.json?.success) {
            span.addEvent("hit");
            span.setStatus({ code: SpanStatusCode6.OK });
            return resp.json.data;
          }
        }
        if (!resp.json?.success && resp.json?.message) {
          throw new Error(resp.json.message);
        }
        throw new Error("unknown error");
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
  /**
   * delete a vector from the vector storage
   *
   * @param name - the name of the vector storage
   * @param key - the key of the vector to delete
   * @returns the number of vector objects that were deleted
   */
  async delete(name, key) {
    const tracer = getTracer();
    const currentContext = context6.active();
    const span = tracer.startSpan(
      "agentuity.vector.delete",
      { attributes: { name, key } },
      currentContext
    );
    try {
      const spanContext = trace5.setSpan(currentContext, span);
      return await context6.with(spanContext, async () => {
        const resp = await DELETE(
          `/vector/2025-03-17/${encodeURIComponent(name)}/${encodeURIComponent(key)}`
        );
        if (resp.status === 200) {
          if (resp.json?.success) {
            span.addEvent("delete_count", resp.json.data);
            span.setStatus({ code: SpanStatusCode6.OK });
            return resp.json.data;
          }
        }
        if (!resp.json?.success && resp.json?.message) {
          throw new Error(resp.json.message);
        }
        throw new Error("unknown error");
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
};

// src/apis/email.ts
init_api();
init_router();
import { context as context7, trace as trace6, SpanStatusCode as SpanStatusCode7 } from "@opentelemetry/api";
var EmailApi = class {
  /**
   * send an email reply to an incoming email
   */
  async sendReply(agentId, email2, authToken, messageId) {
    const tracer = getTracer();
    const currentContext = context7.active();
    const span = tracer.startSpan("agentuity.email.reply", {}, currentContext);
    try {
      const spanContext = trace6.setSpan(currentContext, span);
      return await context7.with(spanContext, async () => {
        span.setAttribute("@agentuity/agentId", agentId);
        span.setAttribute("@agentuity/emailMessageId", messageId);
        const resp = await POST(
          `/email/2025-03-17/${agentId}/reply`,
          email2,
          {
            "Content-Type": "message/rfc822",
            "X-Agentuity-Message-Id": messageId
          },
          void 0,
          authToken
        );
        if (resp.status === 200) {
          span.setStatus({ code: SpanStatusCode7.OK });
          return;
        }
        throw new Error(
          `error sending email reply: ${resp.response.statusText} (${resp.response.status})`
        );
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
};

// src/apis/objectstore.ts
init_types();
init_api();
init_router();
init_util();
init_data();
import { context as context8, trace as trace7, SpanStatusCode as SpanStatusCode8 } from "@opentelemetry/api";
var ObjectStoreAPI = class {
  /**
   * get an object from the object store
   *
   * @param bucket - the bucket to get the object from
   * @param key - the key of the object to get
   * @returns the data result from the object store
   */
  async get(bucket, key) {
    const tracer = getTracer();
    const currentContext = context8.active();
    const span = tracer.startSpan(
      "agentuity.objectstore.get",
      {},
      currentContext
    );
    try {
      span.setAttribute("bucket", bucket);
      span.setAttribute("key", key);
      const spanContext = trace7.setSpan(currentContext, span);
      return await context8.with(spanContext, async () => {
        const resp = await GET(
          `/object/2025-03-17/${encodeURIComponent(bucket)}/${encodeURIComponent(key)}`,
          true
        );
        if (resp.status === 404) {
          span.addEvent("miss");
          span.setStatus({ code: SpanStatusCode8.OK });
          return { exists: false };
        }
        if (resp.status === 200) {
          span.addEvent("hit");
          const body = Buffer.from(await resp.response.arrayBuffer());
          const result = {
            exists: true,
            data: new DataHandler(
              body,
              resp.headers.get("content-type") ?? "application/octet-stream"
            )
          };
          span.setStatus({ code: SpanStatusCode8.OK });
          return result;
        }
        const errorMessage = await resp.response.text();
        throw new Error(
          errorMessage || `error getting object: ${resp.response.statusText} (${resp.response.status})`
        );
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
  /**
   * put an object into the object store
   *
   * @param bucket - the bucket to put the object into
   * @param key - the key of the object to put
   * @param data - the data to put
   * @param params - the object store put parameters
   */
  async put(bucket, key, data, params) {
    if (!isDataType(data)) {
      throw new Error("data must be a DataType");
    }
    const tracer = getTracer();
    const currentContext = context8.active();
    const span = tracer.startSpan(
      "agentuity.objectstore.put",
      {},
      currentContext
    );
    try {
      span.setAttribute("bucket", bucket);
      span.setAttribute("key", key);
      if (params?.contentType) {
        span.setAttribute("contentType", params.contentType);
      }
      if (params?.contentEncoding) {
        span.setAttribute("contentEncoding", params.contentEncoding);
      }
      const spanContext = trace7.setSpan(currentContext, span);
      await context8.with(spanContext, async () => {
        const datavalue = await fromDataType(data, params?.contentType);
        const stream = await datavalue.data.stream();
        const headers = {
          "Content-Type": datavalue.data.contentType
        };
        if (params?.contentEncoding) {
          headers["Content-Encoding"] = params.contentEncoding;
        }
        if (params?.cacheControl) {
          headers["Cache-Control"] = params.cacheControl;
        }
        if (params?.contentDisposition) {
          headers["Content-Disposition"] = params.contentDisposition;
        }
        if (params?.contentLanguage) {
          headers["Content-Language"] = params.contentLanguage;
        }
        if (params?.metadata) {
          for (const [key2, value] of Object.entries(params.metadata)) {
            headers[`x-metadata-${key2}`] = value;
          }
        }
        const resp = await PUT(
          `/object/2025-03-17/${encodeURIComponent(bucket)}/${encodeURIComponent(key)}`,
          stream,
          headers
        );
        if (resp.status >= 200 && resp.status < 300) {
          span.setStatus({ code: SpanStatusCode8.OK });
          return;
        }
        let errorMessage = "";
        try {
          errorMessage = await resp.response.text();
        } catch (textError) {
          errorMessage = resp.response.statusText;
        }
        throw new Error(
          errorMessage || `error putting object: ${resp.response.statusText} (${resp.response.status})`
        );
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
  /**
   * delete an object from the object store
   *
   * @param bucket - the bucket to delete the object from
   * @param key - the key of the object to delete
   * @returns true if the object was deleted, false if the object did not exist
   */
  async delete(bucket, key) {
    const tracer = getTracer();
    const currentContext = context8.active();
    const span = tracer.startSpan(
      "agentuity.objectstore.delete",
      {},
      currentContext
    );
    try {
      span.setAttribute("bucket", bucket);
      span.setAttribute("key", key);
      const spanContext = trace7.setSpan(currentContext, span);
      return await context8.with(spanContext, async () => {
        const resp = await DELETE(
          `/object/2025-03-17/${encodeURIComponent(bucket)}/${encodeURIComponent(key)}`
        );
        if (resp.status === 200) {
          span.addEvent("deleted", { deleted: true });
          span.setStatus({ code: SpanStatusCode8.OK });
          return true;
        }
        if (resp.status === 404) {
          span.addEvent("not_found", { deleted: false });
          span.setStatus({ code: SpanStatusCode8.OK });
          return false;
        }
        const errorMessage = await resp.response.text();
        throw new Error(
          errorMessage || `error deleting object: ${resp.response.statusText} (${resp.response.status})`
        );
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
  /**
   * create a public URL for an object
   *
   * @param bucket - the bucket to create the signed URL for
   * @param key - the key of the object to create the signed URL for
   * @param expiresDuration - the duration of the signed URL in milliseconds
   * @returns the public URL
   */
  async createPublicURL(bucket, key, expiresDuration) {
    const tracer = getTracer();
    const currentContext = context8.active();
    const span = tracer.startSpan(
      "agentuity.objectstore.createPublicURL",
      {},
      currentContext
    );
    try {
      span.setAttribute("bucket", bucket);
      span.setAttribute("key", key);
      if (expiresDuration) {
        span.setAttribute("expiresDuration", expiresDuration);
      }
      const spanContext = trace7.setSpan(currentContext, span);
      return await context8.with(spanContext, async () => {
        const path = `/object/2025-03-17/presigned/${encodeURIComponent(bucket)}/${encodeURIComponent(key)}`;
        const requestBody = {};
        if (expiresDuration) {
          requestBody.expires = expiresDuration;
        }
        const resp = await POST(
          path,
          JSON.stringify(requestBody)
        );
        if (resp.status === 200) {
          if (resp.json?.success) {
            span.setStatus({ code: SpanStatusCode8.OK });
            return resp.json.url;
          }
        }
        if (!resp.json?.success && resp.json?.message) {
          throw new Error(resp.json.message);
        }
        throw new Error(
          `error creating public URL: ${resp.response.statusText} (${resp.response.status})`
        );
      });
    } catch (ex) {
      recordException(span, ex);
      throw ex;
    } finally {
      span.end();
    }
  }
};

// src/server/server.ts
async function createUnifiedServer(config) {
  if (process.env.AGENTUITY_BUNDLER_RUNTIME === "bunjs") {
    const server2 = await Promise.resolve().then(() => (init_bun(), bun_exports));
    return new server2.BunServer(config);
  }
  const server = await Promise.resolve().then(() => (init_node(), node_exports));
  return new server.NodeServer(config);
}
async function createRoute(filename, path, context12, agent, port) {
  const mod = await import(filename);
  let thehandler;
  let thewelcome;
  if (mod.default) {
    thehandler = mod.default;
  } else {
    for (const key in mod) {
      if (key !== "default" && mod[key] instanceof Function) {
        thehandler = mod[key];
        break;
      }
    }
  }
  for (const key in mod) {
    if (key === "welcome" && mod[key] instanceof Function) {
      thewelcome = mod[key];
      break;
    }
  }
  if (!thehandler) {
    throw new Error(`No handler found in ${filename}`);
  }
  const handler = createRouter({
    context: { ...context12, agent },
    handler: thehandler,
    port
  });
  return {
    agent,
    handler,
    welcome: thewelcome,
    method: "POST",
    path
  };
}
async function createServer({
  context: context12,
  directory,
  port,
  logger
}) {
  const routes = [];
  for (const agent of context12.agents) {
    const filepath = join(directory, agent.filename);
    if (existsSync(filepath)) {
      const route = await createRoute(
        filepath,
        `/${agent.id}`,
        context12,
        agent,
        port
      );
      routes.push(route);
      logger.info("registered %s at /%s", agent.name, agent.id);
    } else {
      throw new Error(`${filepath} does not exist for agent ${agent.name}`);
    }
  }
  if (routes.length === 0) {
    throw new Error(`No routes found in ${directory}`);
  }
  return createUnifiedServer({
    logger,
    port,
    routes,
    sdkVersion: context12.sdkVersion
  });
}
var kv = new KeyValueAPI();
var vector = new VectorAPI();
var email = new EmailApi();
var objectstore = new ObjectStoreAPI();
function createServerContext(req) {
  return {
    devmode: req.devmode,
    runId: req.runId,
    deploymentId: req.deploymentId,
    projectId: req.projectId,
    orgId: req.orgId,
    logger: req.logger,
    tracer: req.tracer,
    meter: req.meter,
    kv,
    vector,
    email,
    objectstore,
    sdkVersion: req.sdkVersion,
    agents: req.agents,
    scope: "local"
  };
}

// src/index.ts
init_types();

// src/autostart/index.ts
import { join as join2 } from "node:path";
import yml from "js-yaml";
import { existsSync as existsSync2, readFileSync } from "node:fs";

// src/otel/index.ts
import { NodeSDK } from "@opentelemetry/sdk-node";
import { HostMetrics } from "@opentelemetry/host-metrics";
import { getNodeAutoInstrumentations } from "@opentelemetry/auto-instrumentations-node";
import {
  PeriodicExportingMetricReader,
  MeterProvider
} from "@opentelemetry/sdk-metrics";
import { Resource } from "@opentelemetry/resources";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { OTLPMetricExporter } from "@opentelemetry/exporter-metrics-otlp-http";
import {
  ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION
} from "@opentelemetry/semantic-conventions";
import opentelemetry, {
  metrics,
  propagation as propagation3
} from "@opentelemetry/api";
import {
  W3CTraceContextPropagator,
  W3CBaggagePropagator,
  CompositePropagator
} from "@opentelemetry/core";
import * as LogsAPI2 from "@opentelemetry/api-logs";
import {
  LoggerProvider,
  BatchLogRecordProcessor,
  SimpleLogRecordProcessor
} from "@opentelemetry/sdk-logs";
import { OTLPLogExporter } from "@opentelemetry/exporter-logs-otlp-http";

// node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/legacy-node-configuration.js
var CompressionAlgorithm;
(function(CompressionAlgorithm2) {
  CompressionAlgorithm2["NONE"] = "none";
  CompressionAlgorithm2["GZIP"] = "gzip";
})(CompressionAlgorithm || (CompressionAlgorithm = {}));

// src/otel/logger.ts
import { format } from "node:util";
import * as LogsAPI from "@opentelemetry/api-logs";

// src/logger/console.ts
import { formatWithOptions, inspect as inspect2 } from "node:util";
init_util();
var yellow = "\x1B[33m";
var green = "\x1B[32m";
var red = "\x1B[31m";
var black = "\x1B[1;30m";
var reset = "\x1B[0m";
var ConsoleLogger = class _ConsoleLogger {
  context;
  /**
   * Creates a new console logger
   *
   * @param context - Initial context for the logger
   */
  constructor(context12 = {}) {
    this.context = context12;
  }
  /**
   * Formats a log message with context
   *
   * @param message - The message to format
   * @param args - Additional arguments for formatting
   * @returns The formatted message with context
   * @private
   */
  formatMessage(message, args) {
    const contextStr = this.context && Object.keys(this.context).length > 0 ? Object.entries(this.context).map(([key, value]) => {
      try {
        return `${key}=${typeof value === "object" ? safeStringify(value) : value}`;
      } catch (err) {
        return `${key}=[object Object]`;
      }
    }).join(" ") : "";
    let _message;
    if (typeof message === "string") {
      _message = message;
    } else if (typeof message === "number" || typeof message === "boolean") {
      _message = String(message);
    } else if (message === null) {
      _message = "null";
    } else if (message === void 0) {
      _message = "undefined";
    } else {
      _message = inspect2(message, { depth: null, colors: false });
    }
    let formattedMessage;
    try {
      if (args.length > 0) {
        formattedMessage = formatWithOptions(
          { depth: null },
          _message,
          ...args
        );
      } else {
        formattedMessage = _message;
      }
    } catch (err) {
      formattedMessage = `${_message} ${args.map((arg) => {
        try {
          return typeof arg === "object" ? safeStringify(arg) : String(arg);
        } catch (err2) {
          return "[object Object]";
        }
      }).join(" ")}`;
    }
    return `${formattedMessage}${contextStr ? ` [${contextStr}]` : ""}`;
  }
  /**
   * Log a debug message
   *
   * @param message - The message to log
   * @param args - Additional arguments to log
   */
  debug(message, ...args) {
    try {
      const formattedMessage = this.formatMessage(message, args);
      __originalConsole.debug(`${black}[DEBUG]${reset} ${formattedMessage}`);
    } catch (err) {
      __originalConsole.debug(`${black}[DEBUG]${reset} ${message}`, ...args);
      __originalConsole.error("Error formatting log message:", err);
    }
  }
  /**
   * Log an info message
   *
   * @param message - The message to log
   * @param args - Additional arguments to log
   */
  info(message, ...args) {
    try {
      const formattedMessage = this.formatMessage(message, args);
      __originalConsole.info(`${green}[INFO]${reset}  ${formattedMessage}`);
    } catch (err) {
      __originalConsole.info(`${green}[INFO]${reset}  ${message}`, ...args);
      __originalConsole.error("Error formatting log message:", err);
    }
  }
  /**
   * Log a warning message
   *
   * @param message - The message to log
   * @param args - Additional arguments to log
   */
  warn(message, ...args) {
    try {
      const formattedMessage = this.formatMessage(message, args);
      __originalConsole.warn(`${yellow}[WARN]${reset}  ${formattedMessage}`);
    } catch (err) {
      __originalConsole.warn(`${yellow}[WARN]${reset}  ${message}`, ...args);
      __originalConsole.error("Error formatting log message:", err);
    }
  }
  /**
   * Log an error message
   *
   * @param message - The message to log
   * @param args - Additional arguments to log
   */
  error(message, ...args) {
    try {
      const formattedMessage = this.formatMessage(message, args);
      __originalConsole.error(`${red}[ERROR]${reset} ${formattedMessage}`);
    } catch (err) {
      __originalConsole.error(`${red}[ERROR]${reset} ${message}`, ...args);
      __originalConsole.error("Error formatting log message:", err);
    }
  }
  /**
   * Create a child logger with additional context
   *
   * @param opts - Additional context for the child logger
   * @returns A new logger instance with the additional context
   */
  child(opts) {
    return new _ConsoleLogger({
      ...this.context,
      ...opts
    });
  }
};

// src/otel/logger.ts
init_util();
init_router();
var __originalConsole = Object.create(console);
var OtelLogger = class _OtelLogger {
  delegate;
  context;
  logger;
  constructor(useConsole, delegate, context12) {
    this.delegate = delegate;
    this.context = context12;
    this.logger = useConsole ? new ConsoleLogger() : void 0;
  }
  formatMessage(message) {
    if (typeof message === "string") {
      return message;
    }
    try {
      return safeStringify(message);
    } catch (err) {
      return String(message);
    }
  }
  getAttributes() {
    const attrs = getAgentDetail();
    if (!attrs) {
      return this.context;
    }
    const result = {
      ...this.context ?? {}
    };
    for (const [key, value] of Object.entries(attrs)) {
      if (value !== null && value !== void 0) {
        result[`@agentuity/${key}`] = value;
      }
    }
    return result;
  }
  debug(message, ...args) {
    this.logger?.debug(message, ...args);
    let body;
    try {
      body = format(this.formatMessage(message), ...args);
    } catch (err) {
      body = `${this.formatMessage(message)} ${args.map((arg) => String(arg)).join(" ")}`;
    }
    this.delegate.emit({
      severityNumber: LogsAPI.SeverityNumber.DEBUG,
      severityText: "DEBUG",
      body,
      attributes: this.getAttributes()
    });
  }
  info(message, ...args) {
    this.logger?.info(message, ...args);
    let body;
    try {
      body = format(this.formatMessage(message), ...args);
    } catch (err) {
      body = `${this.formatMessage(message)} ${args.map((arg) => String(arg)).join(" ")}`;
    }
    this.delegate.emit({
      severityNumber: LogsAPI.SeverityNumber.INFO,
      severityText: "INFO",
      body,
      attributes: this.getAttributes()
    });
  }
  warn(message, ...args) {
    this.logger?.warn(message, ...args);
    let body;
    try {
      body = format(this.formatMessage(message), ...args);
    } catch (err) {
      body = `${this.formatMessage(message)} ${args.map((arg) => String(arg)).join(" ")}`;
    }
    this.delegate.emit({
      severityNumber: LogsAPI.SeverityNumber.WARN,
      severityText: "WARN",
      body,
      attributes: this.getAttributes()
    });
  }
  error(message, ...args) {
    this.logger?.error(message, ...args);
    let body;
    try {
      body = format(this.formatMessage(message), ...args);
    } catch (err) {
      body = `${this.formatMessage(message)} ${args.map((arg) => String(arg)).join(" ")}`;
    }
    this.delegate.emit({
      severityNumber: LogsAPI.SeverityNumber.ERROR,
      severityText: "ERROR",
      body,
      attributes: this.getAttributes()
    });
  }
  child(opts) {
    return new _OtelLogger(!!this.logger, this.delegate, {
      ...this.context ?? {},
      ...opts
    });
  }
};
function createLogger(useConsole, context12) {
  const delegate = LogsAPI.logs.getLogger("default");
  return new OtelLogger(useConsole, delegate, context12);
}
function patchConsole(enabled, attributes) {
  if (!enabled) {
    return;
  }
  const _patch = { ...__originalConsole };
  const delegate = createLogger(true, attributes);
  _patch.log = (...args) => {
    delegate.info(args[0], ...args.slice(1));
  };
  _patch.error = (...args) => {
    delegate.error(args[0], ...args.slice(1));
  };
  _patch.warn = (...args) => {
    delegate.warn(args[0], ...args.slice(1));
  };
  _patch.debug = (...args) => {
    delegate.debug(args[0], ...args.slice(1));
  };
  _patch.info = (...args) => {
    delegate.info(args[0], ...args.slice(1));
  };
  _patch.dir = (...args) => {
    let msg = "";
    if (args.length === 1) {
      msg = format(args[0]);
    } else if (args.length > 2) {
      msg = format(args[0], args[1]);
    } else {
      msg = safeStringify(args);
    }
    delegate.debug(msg);
  };
  _patch.dirxml = (...args) => {
    delegate.debug("dirxml:", ...args);
  };
  _patch.table = (...args) => {
    delegate.debug("table:", ...args);
  };
  _patch.trace = (...args) => {
    delegate.debug(args[0], ...args.slice(1));
  };
  _patch.group = (...args) => {
    delegate.debug("group:", ...args);
  };
  _patch.groupCollapsed = (...args) => {
    delegate.debug("groupCollapsed:", ...args);
  };
  _patch.groupEnd = () => {
    delegate.debug("groupEnd");
  };
  _patch.clear = () => {
  };
  _patch.count = (...args) => {
    delegate.debug("count:", ...args);
  };
  _patch.countReset = (...args) => {
    delegate.debug("countReset:", ...args);
  };
  _patch.assert = (condition, ...args) => {
    if (!condition) {
      delegate.error("assertion failed:", ...args);
    }
  };
  _patch.time = (...args) => {
    delegate.debug("time:", ...args);
  };
  _patch.timeLog = (...args) => {
    delegate.debug("timeLog:", ...args);
  };
  _patch.timeEnd = (...args) => {
    delegate.debug("timeEnd:", ...args);
  };
  _patch.profile = (...args) => {
    delegate.debug("profile:", ...args);
  };
  _patch.profileEnd = (...args) => {
    delegate.debug("profileEnd:", ...args);
  };
  console = globalThis.console = _patch;
}

// src/otel/console.ts
import { ExportResultCode } from "@opentelemetry/core";
import { SeverityNumber as SeverityNumber2 } from "@opentelemetry/api-logs";
var ConsoleLogRecordExporter = class {
  logger;
  /**
   * Creates a new console log record exporter
   */
  constructor() {
    this.logger = new ConsoleLogger();
  }
  /**
   * Exports log records to the console
   *
   * @param logs - The log records to export
   * @param resultCallback - Callback function to report the export result
   */
  export(logs3, resultCallback) {
    for (const log of logs3) {
      switch (log.severityNumber) {
        case SeverityNumber2.DEBUG:
          this.logger.debug(log.body);
          break;
        case SeverityNumber2.INFO:
          this.logger.info(log.body);
          break;
        case SeverityNumber2.WARN:
          this.logger.warn(log.body);
          break;
        case SeverityNumber2.ERROR:
          this.logger.error(log.body);
          break;
        default:
          this.logger.info(log.body);
          break;
      }
    }
    resultCallback({ code: ExportResultCode.SUCCESS });
  }
  /**
   * Shuts down the exporter
   *
   * @returns A promise that resolves when shutdown is complete
   */
  shutdown() {
    return Promise.resolve();
  }
};

// src/otel/fetch.ts
import {
  context as context11,
  trace as trace10,
  propagation as propagation2,
  SpanStatusCode as SpanStatusCode11
} from "@opentelemetry/api";
var __originalFetch = fetch;
function instrumentFetch() {
  const patch = async (input, init) => {
    const url = typeof input === "string" ? input : input instanceof URL ? input.toString() : input.url;
    const method = init?.method || (typeof input !== "string" && !(input instanceof URL) ? input.method || "GET" : "GET");
    const activeSpan = trace10.getActiveSpan();
    if (!activeSpan) {
      return __originalFetch(input, init);
    }
    const currentContext = context11.active();
    const _url = new URL(url);
    const childSpan = trace10.getTracer("fetch").startSpan(
      `HTTP ${method}`,
      {
        attributes: {
          "http.url": url,
          "http.path": _url.pathname,
          "http.method": method,
          host: _url.host
        }
      },
      currentContext
    );
    try {
      const headers = new Headers(init?.headers || {});
      const carrier = {};
      const newContext = trace10.setSpan(currentContext, childSpan);
      propagation2.inject(newContext, carrier);
      for (const [key, value] of Object.entries(carrier)) {
        headers.set(key, value);
      }
      const newInit = {
        ...init,
        headers
      };
      const response = await __originalFetch(input, newInit);
      childSpan.setAttributes({
        "http.status_code": response.status,
        "http.user_agent": response.headers.get("user-agent") || ""
      });
      if (!response.ok) {
        childSpan.setStatus({ code: SpanStatusCode11.ERROR });
      } else {
        childSpan.setStatus({ code: SpanStatusCode11.OK });
      }
      return response;
    } catch (error) {
      childSpan.recordException(error);
      childSpan.setStatus({ code: SpanStatusCode11.ERROR });
      throw error;
    } finally {
      childSpan.end();
    }
  };
  globalThis.fetch = patch;
}

// src/otel/index.ts
var devmodeExportInterval = 1e3;
var productionExportInterval = 1e4;
function registerOtel(config) {
  const {
    url,
    name,
    version,
    bearerToken,
    environment = "development",
    sdkVersion,
    cliVersion,
    orgId,
    projectId,
    deploymentId,
    devmode: devmode2 = false
  } = config;
  let headers;
  if (bearerToken) {
    headers = {};
    headers.Authorization = `Bearer ${bearerToken}`;
  }
  const resource = new Resource({
    [ATTR_SERVICE_NAME]: name,
    [ATTR_SERVICE_VERSION]: version,
    "@agentuity/orgId": orgId ?? "unknown",
    "@agentuity/projectId": projectId ?? "unknown",
    "@agentuity/deploymentId": deploymentId ?? "unknown",
    "@agentuity/env": environment,
    "@agentuity/devmode": devmode2,
    "@agentuity/sdkVersion": sdkVersion ?? "unknown",
    "@agentuity/cliVersion": cliVersion ?? "unknown"
  });
  let otlpLogExporter;
  let logRecordProcessor;
  if (url) {
    otlpLogExporter = new OTLPLogExporter({
      url: `${url}/v1/logs`,
      headers,
      compression: CompressionAlgorithm.GZIP,
      timeoutMillis: 1e4
    });
    logRecordProcessor = new BatchLogRecordProcessor(otlpLogExporter);
  } else {
    logRecordProcessor = new SimpleLogRecordProcessor(
      new ConsoleLogRecordExporter()
    );
  }
  const loggerProvider = new LoggerProvider({
    resource
  });
  loggerProvider.addLogRecordProcessor(logRecordProcessor);
  LogsAPI2.logs.setGlobalLoggerProvider(loggerProvider);
  const logger = createLogger(!!url);
  patchConsole(!!url, {
    "@agentuity/orgId": orgId ?? "unknown",
    "@agentuity/projectId": projectId ?? "unknown",
    "@agentuity/deploymentId": deploymentId ?? "unknown",
    "@agentuity/env": environment,
    "@agentuity/devmode": devmode2,
    "@agentuity/language": "javascript"
  });
  const traceExporter = url ? new OTLPTraceExporter({
    url: `${url}/v1/traces`,
    headers,
    keepAlive: true
  }) : void 0;
  const metricExporter = url ? new OTLPMetricExporter({
    url: `${url}/v1/metrics`,
    headers,
    keepAlive: true
  }) : void 0;
  const sdkMetricReader = url && metricExporter ? new PeriodicExportingMetricReader({
    exporter: metricExporter,
    exportTimeoutMillis: devmode2 ? devmodeExportInterval : productionExportInterval,
    exportIntervalMillis: devmode2 ? devmodeExportInterval : productionExportInterval
  }) : void 0;
  const hostMetricReader = url && metricExporter ? new PeriodicExportingMetricReader({
    exporter: metricExporter,
    exportTimeoutMillis: devmode2 ? devmodeExportInterval : productionExportInterval,
    exportIntervalMillis: devmode2 ? devmodeExportInterval : productionExportInterval
  }) : void 0;
  const meterProvider = hostMetricReader ? new MeterProvider({
    resource,
    readers: [hostMetricReader]
  }) : void 0;
  if (meterProvider) {
    metrics.setGlobalMeterProvider(meterProvider);
  }
  const hostMetrics = meterProvider ? new HostMetrics({ meterProvider }) : void 0;
  let running = false;
  let instrumentationSDK;
  if (url) {
    const propagator = new CompositePropagator({
      propagators: [
        new W3CTraceContextPropagator(),
        new W3CBaggagePropagator()
      ]
    });
    propagation3.setGlobalPropagator(propagator);
    instrumentFetch();
    instrumentationSDK = new NodeSDK({
      logRecordProcessor,
      traceExporter,
      metricReader: sdkMetricReader,
      instrumentations: [getNodeAutoInstrumentations()],
      resource,
      textMapPropagator: propagator
    });
    instrumentationSDK.start();
    hostMetrics?.start();
    running = true;
  }
  const tracer = opentelemetry.trace.getTracer(name, version);
  const meter = metrics.getMeter(name, version);
  const shutdown = async () => {
    if (running) {
      running = false;
      logger.debug("shutting down OpenTelemetry");
      await otlpLogExporter?.forceFlush().catch(
        (e) => logger.warn("error in forceFlush of otel exporter. %s", e)
      );
      await otlpLogExporter?.shutdown().catch(
        (e) => !devmode2 && logger.warn("error in shutdown of otel exporter. %s", e)
      );
      await instrumentationSDK?.shutdown().catch(
        (e) => !devmode2 && logger.warn("error in shutdown of otel instrumentation. %s", e)
      );
      logger.debug("shut down OpenTelemetry");
    }
  };
  if (url) {
    logger.debug("connected to Agentuity Agent Cloud");
  }
  return { tracer, meter, logger, shutdown };
}

// src/autostart/index.ts
async function run(config) {
  let { port } = config;
  const { basedir } = config;
  if (process.env.AGENTUITY_ENVIRONMENT !== "production") {
    const shouldAttemptLoad = !config.projectId || !config.agents || !config.agents.length || !config.port && !process.env.AGENTUITY_CLOUD_PORT && !process.env.PORT;
    if (shouldAttemptLoad) {
      let ymlfile = join2(basedir, "agentuity.yaml");
      if (!existsSync2(ymlfile)) {
        ymlfile = join2(basedir, "..", "agentuity.yaml");
      }
      if (!existsSync2(ymlfile)) {
        console.error(
          "[ERROR] Failed to find the agentuity.yaml file in the current directory"
        );
        process.exit(1);
      }
      const ymlData = readFileSync(ymlfile, "utf8").toString();
      const data = yml.load(ymlData);
      if (!config.projectId && data?.project_id) {
        config.projectId = data.project_id;
      }
      if (data?.development?.port && !process.env.AGENTUITY_CLOUD_PORT && !process.env.PORT) {
        port = data.development.port;
      }
      if (!config.agents || config.agents.length === 0) {
        const agentdir = data?.bundler?.agents?.dir;
        if (agentdir && existsSync2(agentdir)) {
          config.agents = data.agents.map((agent) => {
            const filename = join2(agentdir, agent.name, "index.ts");
            if (existsSync2(filename)) {
              return {
                ...agent,
                filename
              };
            }
          }).filter(Boolean);
        }
      }
    }
  }
  if (!config.projectId) {
    throw new Error(
      "projectId is required and not found either in agentuity.yaml or in the environment"
    );
  }
  const name = process.env.AGENTUITY_SDK_APP_NAME ?? "unknown";
  const version = process.env.AGENTUITY_SDK_APP_VERSION ?? "unknown";
  const sdkVersion = process.env.AGENTUITY_SDK_VERSION ?? "unknown";
  const otel = registerOtel({
    name,
    version,
    sdkVersion,
    cliVersion: config.cliVersion,
    devmode: config.devmode,
    orgId: config.orgId,
    projectId: config.projectId,
    deploymentId: config.deploymentId,
    bearerToken: config?.otlp?.bearerToken,
    url: config?.otlp?.url,
    environment: config.devmode ? "development" : config.environment
  });
  const server = await createServer({
    context: createServerContext({
      devmode: config.devmode,
      deploymentId: config.deploymentId,
      projectId: config.projectId,
      orgId: config.orgId,
      logger: otel.logger,
      tracer: otel.tracer,
      meter: otel.meter,
      sdkVersion,
      agents: config.agents
    }),
    directory: basedir,
    port: process.env.AGENTUITY_CLOUD_PORT ? Number.parseInt(process.env.AGENTUITY_CLOUD_PORT) : process.env.PORT ? Number.parseInt(process.env.PORT) : port ?? 3500,
    logger: otel.logger
  });
  await server.start();
  const shutdown = async () => {
    await server.stop();
    await otel.shutdown();
  };
  process.on("beforeExit", shutdown);
  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);
  process.on("SIGQUIT", shutdown);
}

// src/index.ts
async function runner(autoStart = false, dir = process.env.AGENTUITY_SDK_DIR) {
  if (autoStart && !!dir) {
    const agentsJSON = process.env.AGENTUITY_CLOUD_AGENTS_JSON;
    let agents = [];
    if (agentsJSON) {
      agents = JSON.parse(agentsJSON);
    } else {
      console.warn(
        "[WARN] expected AGENTUITY_CLOUD_AGENTS_JSON to be set but it was not. will attempt to load manually."
      );
    }
    await run({
      basedir: dir,
      orgId: process.env.AGENTUITY_CLOUD_ORG_ID,
      projectId: process.env.AGENTUITY_CLOUD_PROJECT_ID,
      deploymentId: process.env.AGENTUITY_CLOUD_DEPLOYMENT_ID,
      port: process.env.AGENTUITY_CLOUD_PORT ? Number.parseInt(process.env.AGENTUITY_CLOUD_PORT) : process.env.PORT ? Number.parseInt(process.env.PORT) : void 0,
      devmode: process.env.AGENTUITY_SDK_DEV_MODE === "true",
      cliVersion: process.env.AGENTUITY_CLI_VERSION,
      environment: process.env.AGENTUITY_ENVIRONMENT ?? process.env.NODE_ENV ?? "development",
      otlp: {
        url: process.env.AGENTUITY_OTLP_URL,
        bearerToken: process.env.AGENTUITY_OTLP_BEARER_TOKEN
      },
      agents
    });
  }
}
export {
  createServer,
  createServerContext,
  isDataObject,
  isDataType,
  isJsonObject,
  runner
};
//# sourceMappingURL=index.js.map
import type { AgentResponse, InvocationArguments, GetAgentRequestParams, AgentResponseData, DataType, AgentRedirectResponse, ReadableDataType } from '../types';
import type { ReadableStream } from 'node:stream/web';
/**
 * The AgentResponse class implements the AgentResponseHandler interface.
 * It is used to create and return responses from an agent.
 */
export default class AgentResponseHandler implements AgentResponse {
    /**
     * redirect the current request another agent within the same project
     */
    handoff<M = unknown>(agent: GetAgentRequestParams, args?: InvocationArguments): Promise<AgentRedirectResponse>;
    /**
     * return an empty response with optional metadata
     */
    empty<M = unknown>(metadata?: M): Promise<AgentResponseData>;
    /**
     * return a JSON response with optional metadata
     */
    json<T = unknown, M = unknown>(data: T, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a text response with optional metadata
     */
    text<M = unknown>(data: string, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a binary response with optional metadata
     */
    binary<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a PDF response with optional metadata
     */
    pdf<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a PNG response with optional metadata
     */
    png<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a JPEG response with optional metadata
     */
    jpeg<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a GIF response with optional metadata
     */
    gif<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a WebP response with optional metadata
     */
    webp<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a MP3 response with optional metadata
     */
    mp3<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a MP4 response with optional metadata
     */
    mp4<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a M4A response with optional metadata
     */
    m4a<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a M4P response with optional metadata
     */
    m4p<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a WebM response with optional metadata
     */
    webm<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a HTML response with optional metadata
     */
    html<M = unknown>(data: string, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a WAV response with optional metadata
     */
    wav<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * return an OGG response with optional metadata
     */
    ogg<M = unknown>(data: DataType, metadata?: M): Promise<AgentResponseData>;
    /**
     * stream a response to the client
     */
    stream<M = unknown>(stream: ReadableStream<ReadableDataType> | AsyncIterable<ReadableDataType>, contentType?: string, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a response with specific data and content type with optional metadata
     */
    data<M = unknown>(data: DataType, contentType: string, metadata?: M): Promise<AgentResponseData>;
    /**
     * return a markdown response with optional metadata
     */
    markdown<M = unknown>(content: string, metadata?: M): Promise<AgentResponseData>;
}
//# sourceMappingURL=response.d.ts.map
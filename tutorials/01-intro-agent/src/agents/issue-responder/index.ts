import type {AgentRequest, AgentResponse, AgentContext } from '@agentuity/sdk';
import OpenAI from 'openai';

const client = new OpenAI();

// Dev Mode
export const welcome = () => {
  return {
    welcome: 'Welcome to the GitHub Issue Triage Agent! Please provide a GitHub issue URL to analyze and triage.',
    prompts: [
      {
        // bug report
        data: 'https://github.com/parteeksingh24/github-issue-triage/issues/1',
        contentType: 'text/plain',
      },
      {
        // feature request
        data: 'https://github.com/parteeksingh24/github-issue-triage/issues/2',
        contentType: 'text/plain',
      },
    ],
  };
};

// Parse GitHub URL and extract owner, repo, issue number
function parseGitHubURL(url: string): { owner: string; repo: string; issueNumber: string } | null {
  try {
    // 1. Parse the URL using JavaScript's built-in URL constructor
    const urlObject = new URL(url.trim());
    
    // 2. Check if it's actually a GitHub URL
    if (urlObject.hostname !== 'github.com') {
      return null;
    }
    
    // 3. Split the path into parts: /owner/repo/issues/number
    const pathParts = urlObject.pathname.split('/');
    // Expected structure: ['', 'owner', 'repo', 'issues', 'number']
    
    // 4. Validate the URL structure
    if (pathParts.length !== 5 || pathParts[3] !== 'issues') {
      return null;
    }
    
    // 5. Extract the parts we need
    const owner = pathParts[1];
    const repo = pathParts[2]; 
    const issueNumber = pathParts[4];
    
    // 6. Make sure all parts exist and are valid
    if (!owner || !repo || !issueNumber) {
      return null;
    }
    
    return { owner, repo, issueNumber };
  } catch (error) {
    // Invalid URL format will throw an error
    return null;
  }
}

// Fetch issue data from GitHub API
async function fetchGitHubIssue(owner: string, repo: string, issueNumber: string): Promise<any> {
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    throw new Error('GITHUB_TOKEN not configured');
  }

  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}`,
    {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github+json',
        'X-GitHub-Api-Version': '2022-11-28'
      }
    }
  );

  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Issue not found');
    }
    throw new Error(`GitHub API error: ${response.status}`);
  }

  return await response.json();
}

// Issue analysis and response generation
async function triageIssue(issue: any): Promise<{ type: string; comment: string }> {
  const prompt = `You are a helpful GitHub issue triage assistant. Analyze this issue and provide both a classification and a friendly comment.

ISSUE TITLE: ${issue.title || 'No title'}

ISSUE BODY: ${issue.body || 'No description provided'}

Please:
1. Classify this issue as one of: bug, feature-request, question, or documentation
2. Generate a helpful, friendly comment to post on the issue
3. IMPORTANT: End your comment with this exact signature:

---
ðŸ¤– *This comment was generated by our GitHub Issue Triage Agent*

Respond with ONLY this JSON format:
{
  "type": "bug|feature-request|question|documentation",
  "comment": "A helpful comment thanking them and explaining next steps based on the issue type, ending with the bot signature"
}`;

  const result = await client.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [{ role: 'user', content: prompt }],
    temperature: 0.3,
  });

  try {
    const response = JSON.parse(result.choices[0]?.message.content || '{}');
    return {
      type: response.type || 'question',
      comment: response.comment || 'Thank you for opening this issue! Our team will review it soon.'
    };
  } catch (error) {
    // Fallback if JSON parsing fails
    return {
      type: 'question',
      comment: 'Thank you for opening this issue! Our team will review it soon.'
    };
  }
}

// Post comment to GitHub issue
async function postComment(owner: string, repo: string, issueNumber: string, comment: string): Promise<void> {
  const token = process.env.GITHUB_TOKEN;
  if (!token) throw new Error('GITHUB_TOKEN not configured');

  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'X-GitHub-Api-Version': '2022-11-28'
      },
      body: JSON.stringify({ body: comment })
    }
  );

  if (!response.ok) {
    throw new Error(`Failed to post comment: ${response.status} ${response.statusText}`);
  }
}

// Apply label to GitHub issue
async function applyLabel(owner: string, repo: string, issueNumber: string, label: string): Promise<void> {
  const token = process.env.GITHUB_TOKEN;
  if (!token) throw new Error('GITHUB_TOKEN not configured');

  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/labels`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'X-GitHub-Api-Version': '2022-11-28'
      },
      body: JSON.stringify({ labels: [label] })
    }
  );

  if (!response.ok) {
    throw new Error(`Failed to apply label: ${response.status} ${response.statusText}`);
  }
}

// The main agent ("orchestrator") logic
export default async function Agent(
  req: AgentRequest,
  resp: AgentResponse,
  ctx: AgentContext
) {
  try {
    // 1. Get and validate GitHub URL
    ctx.logger.info('Request content type:', { contentType: req.data.contentType });
    
    // Get GitHub URL from request
    const url = await req.data.text();
    ctx.logger.info('Processing GitHub issue URL', { url });

    const parsed = parseGitHubURL(url);
    if (!parsed) {
      return resp.json({ 
        error: 'Invalid GitHub URL format',
        message: 'Please provide a valid GitHub issue URL like: https://github.com/owner/repo/issues/123'
      });
    }

    const { owner, repo, issueNumber } = parsed;

    // 2. Fetch issue data from GitHub
    ctx.logger.info('Fetching issue from GitHub', { owner, repo, issueNumber });
    const issue = await fetchGitHubIssue(owner, repo, issueNumber);

    // 3. Classify issue (tag/label) and generate a comment
    ctx.logger.info('Analyzing issue with AI', { title: issue.title });
    const { type, comment } = await triageIssue(issue);
    ctx.logger.info('AI analysis complete', { type });

    // 4. Act based on classification
    const actions: string[] = [];

    // Post AI-generated comment
    ctx.logger.info('Posting AI-generated comment');
    await postComment(owner, repo, issueNumber, comment);
    actions.push('posted AI-generated comment');

    // Apply tag/label
    ctx.logger.info('Applying label based on AI classification', { label: type });
    await applyLabel(owner, repo, issueNumber, type);
    actions.push(`applied "${type}" label`);

    // 5. Log detailed response for debugging
    ctx.logger.info('Detailed response for debugging:', { 
      success: true,
      url,
      classification: type, 
      actionsCount: actions.length,
      issueTitle: issue.title,
      actions
    });
    
    // Return simplified response
    return resp.json({ 
      success: true, 
      message: `âœ… Successfully triaged! AI classified as "${type}" and took appropriate actions.`
    });

  } catch (error) {
    ctx.logger.error('Error processing GitHub issue', error);
    
    const message = error instanceof Error ? error.message : 'Unknown error occurred';
    return resp.json({ 
      error: 'Failed to process GitHub issue',
      message
    });
  }
}
